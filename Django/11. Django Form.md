# Django Form
### HTML Form의 한계
- 비정상적인 혹은 악의적인 요청을 필터링할 수 없음
- 유효한 데이터인지 확인이 필요

### 유효성 검사
- 수집한 데이터가 정확하고 유효한지 확인하는 과정
- Django Form의 유효성 검사는 사용자가 입력한 데이터가 올바른 형식인지 자동으로 점검
- 이를 통해 서버에 잘못된 데이터가 저장되지 않도록 보호할 수 있음

### 유효성 검사 구현의 어려움
- 유효성 검사를 구현하기 위해서는 입력 값, 형식, 중복, 범위, 보안 등 많은 것들을 고려해야 함
- 이런 과정과 기능을 직접 개발하지 않고, Django가 제공하는 Form을 사용

## Form class
### Django Form
- 사용자 입력 데이터를 수집하고, 처리 및 유효성 검사를 수행하기 위한 도구
- 유효성 검사를 단순화하고 자동화 할 수 있는 기능을 제공
- 사용자가 잘못 입력한 데이터는 자동으로 오류로 처리되어 안전성을 높임
- 빠르고 일관된 입력 검증 기능을 구현할 수 있음

### Form Class 정의
```python
# articles/forms.py

from django import forms

class ArticleForm(forms.Form):
    title = forms.CharField(max_length=10)
    content = forms.CharField()
```
- Form Class를 상속받아 내용과 제목에 대한 사용자 입력을 받는 ArticleForm을 정의

### Form Class 적용
```python
# articles/views.py

from .forms import ArticleForm

def new(request):
    form = ArticleForm()
    context = {
        'form': form,
    }
    return render(request, 'articles/new.html', context)
```
```html
<!-- articles/new.html -->
<h1>NEW</h1>
<form action="{% url 'articles:create' %}" method="POST">
	{% csrf token %}
	{{ form }}
	<input type="submit">
</form>
```

## Widgets
### Widgets
- HTML 'input' element의 표현을 담당
- Django Form의 widgets은 각 필드가 HTML에서 어떻게 렌더링 될지를 결정

### Widget 적용
```python
# articles/form.py

from django import forms

class ArticleForm(forms.Form):
    title = forms.CharField(max_length=10)
    content = forms.CharField(widget=forms.Textarea)
```

# Django ModelForm
### ModelForm
- Model과 연결된 Form을 자동으로 생성해주는 기능을 제공
- 데이터 수집과 저장 과정을 동시에 처리할 수 있도록 도와줌

### ModelForm class 정의
```python
# articles/forms.py

from django import forms
from .models import Article

class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        fields = '__all__'
```

## Meta class
### Meta class
- ModelForm의 정보를 작성하는 곳
- ModelForm 내부에서 어떤 모델과 연결할 지, 어떤 필드를 사용할 지 등을 정의하는 설정 공간
- Form의 동작 방식을 제어하는 핵심 역할을 함

### `fields`, `exclude`
```python
# articles/forms.py

class ArticleForm(forms.ModelForm):
    class Meta:
        model = Article
        exclude = ('title', )
```
- `exclude` 속성을 사용해 모델에서 포함하지 않도록 필드를 지정할 수도 있음

### Meta class 주의사항
- Django에서 ModelForm에 대한 추가 정보나 속성을 작성하는 클래스 구조를 Meta 클래스로 작성했을 뿐이며, 파이썬의 inner class와 같은 문법적인 관점으로 접근하지 말 것

## ModelForm 적용
### ModelForm을 적용한 create 로직
```python
# articles/views.py

from .forms import ArticleForm

def create(request):
    form = ArticleForm(request.POST)
    if form.is_valid():
        article = form.save()
        return redirect('articles:detail', article.pk)
    context = {
        'form' = form,
    }
    return render(request, 'articles/new.html', context)
```

### `is_valid()` 활용
- 여러 유효성 검사를 실행하고, 데이터가 유효한지 여부를 Boolean으로 반환

### ModelForm을 적용한 edit 로직
```python
# articles/views.py

def edit(request, pk):
    article = Article.objects.get(pk=pk)
    form = ArticleForm(instance=article)
    context = {
        'article': article,
        'form': form,
    }
    return render(request, 'articles/edit.html', context)
```
```html
<!-- articles/edit.html -->

<h1>EDIT</h1>
<form action="{% url 'articles:update' article.pk %}" method="POST">
	{% csrf_token %}
	{{ form }}
	<input type="submit">
</form>
```

### ModelForm을 적용한 update 로직
```python
# articles/views.py

def update(request, pk):
    article = Article.objects.get(pk=pk)
    form = ArticleForm(request.POST, instance=article)
    if form.is_valid():
        form.save()
        return redirect('articles:detail', article.pk)
    context = {
        'article': article,
        'form': form,
    }
    return render(request, 'articles/edit.html', context)
```

## save 메서드
### `save()`
- 데이터베이스 객체를 만들고 저장하는 ModelForm의 인스턴스 메서드
- Form 데이터가 유효한 경우, `save()` 메서드를 호출하면 모델 인스턴스를 생성하고 데이터베이스에 저장됨
- instance 인자를 통해 새 객체 생성과 기존 객체 수정도 구분할 수 있음
- 이 과정을 통해 손쉽게 DB 연동이 가능

### `save()` 메서드가 생성과 수정을 구분하는 법
```python
# CREATE

form = ArticleForm(request.POST)
form.save()
```
```python
# UPDATE

form = Articleform(request.POST, instance=article)
form.save()
```
- 키워드 인자 `instance` 여부를 통해 생성할 지, 수정할 지를 결정

# HTTP 요청 다루기
## view 함수 구조 변화
- HTTP request method 차이점을 활용해 동일한 목적을 가지는 2개의 view 함수를 하나로 구조화
## new & create 함수 결합
```python
# articles/views.py

def create(request):
    if request.method == "POST":
        form = ArticleFrom(request.POST)
        if form.is_valid():
            article = form.save()
            return redirect('articles:detail', article.pk)
    else:
        form = ArticleForm()
    context = {
        'form': form,
    }
    return render(request, 'articles/new.html', context)
```
## edit & update 함수 결합
```python
# articles/views.py

def update(request, pk):
    article = Article.objects.get(pk=pk)
    if request.method == "POST":
        form = ArticleForm(request.POST, instance=article)
        if form.is_valid():
            form.save()
            return redirect('articles:detail', article.pk)
    else:
        form = ArticleForm(instance=article)
    context = {
        'article': article,
        'form': form,
    }
    return render(request, 'articles/update.html', context)
```