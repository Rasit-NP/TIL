# Read
```python
# articles/urls.py

urlpatterns = [
    ...
    path('<int:pk>', views.detail, name='detail'),
]
```
```python
# articles/view.py

def detail(request, pk):
    article = Article.objects.get(pk=pk)
    context = {
        'article': article,
    }
    return render(request, 'qrticles/detail.html', context)
```
```html
<!-- templates/articles/detail.html -->

<h2>DETAIL</h2>
<h3>{{ article.pk }} 번째 글</h3>
<hr>
	<p>제목: {{ article.title }}</p>
	<p>내용: {{ article.content }}</p>
	<p>작성일: {{ article.created_at }}</p>
	<p>수정일: {{ article.updated_at }}</p>
<a href="{% url 'articles:index' %}">[back]</a>
```
```html
<!-- templates/articles/index.html -->

<h1>Articles</h1>
<hr>
	{% for article in articles %}
	<p>글 번호: {{ articles.pk }}</p>
	<a href="{% url 'articles:detail' article.pk %}">
		<p>글 제목: {{article.title }}</p>
	</a>
	<p>글 내용: {{ article.content }}</p>
	<hr>
	{% endfor %}
```

# Create
- 필요한 함수
1. new
    - 사용자 입력을 받을 페이지를 렌더링
2. create
    - 사용자가 입력한 요청 데이터를 받아 DB에 저장

### new
```python
# articles/urls.py

urlpatterns = [
    ...
    path('new/', views.new, name='new')
]
```
```python
# articles/views.py

def new(request):
    return render(request, 'articles/new.html')
```
```html
<!-- templates/articles/new.html -->

<h1>NEW</h1>
<form action="#" method="GET">
	<div>
		<label for="title">Title: </label>
		<input type="text" name="title" id="title">
	</div>
	<div>
		<label for="content">Content: </label>
		<textarea name="content" id="content"></textarea>
	</div>
	<input type="submit">
</form>
<hr>
<a href="{% url 'articles:index' %}">[back]</a>
```

### create
```python
# articles/urls.py

urlpatterns = [
    ...
    path('create/', views.create, name='create')
]
```
```python
# articles/views.py

def create(request):
    title = request.GET.get('title')
    content = request.GET.get('content')

    article = Article(title=title, content=content)
    article.save()

    return render(request, 'articles/create.html')
```
```html
<!-- templates/articles/new.html -->

<h1>NEW</h1>
<form action="{% url 'articles:create' %}" method="GET">
	<div>
		<label for="title">Title: </label>
		<input type="text" name="title" id="title">
	</div>
	<div>
		<label for="content">Content: </label>
		<textarea name="content" id="content"></textarea>
	</div>
	<input type="submit">
</form>
<hr>
<a href="{% url 'articles:index' %}">[back]</a>
```

# HTTP request methods
- 데이터에 대해 수행을 원하는 작업을 나타내는 것
- 서버에게 원하는 작업의 종류를 알려줌
- 대표적인 메서드
    - GET
        - 리소스 조회
            - URL에 데이터가 노출됨
            - 캐싱 가능
    - POST
        - 데이터 생성/전송
            - 요청 본문에 데이터
            - 데이터 노출 없음
## GET method
- 서버로부터 데이터를 요청하고 받아오는데 사용
- 쿼리 전송, 웹페이지 요청, API에서 데이터 조회

### GET method 특징
1. 데이터 전송
    - URL의 Query String을 통해 데이터를 전송
2. 데이터의 제한
    - URL 길이에 제한이 있어 대량의 데이터 전송에는 적합하지 않음
3. 브라우저 히스토리
    - 요청 URL이 브라우저 히스토리에 남음
4. 캐싱
    - 브라우저는 GET 요청의 응답을 로컬에 저장할 수 있음
    - 동일한 URL로 다시 요청할 때, 서버에 접속하지 않고 저장된 결과를 사용
    - 페이지 로딩 시간을 크게 단축

## POST method
```html
<form action="{% url 'articles:create' %}" method="POST"></form>
```
```python
def create(request):
    title = request.POST.get('title')
    content = request.POST.get('content')
```
- 서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제)하는데 사용
- 로그인 정보 제출, 파일 업로드, 새 데이터 생성, API에서 데이터 변경을 요청

### POST method 특징
1. 데이터 전송
    - HTTP Body를 통해 데이터를 전송
2. 데이터 제한
    - GET에 비해 더 많은 양의 데이터를 전송할 수 있음
3. 브라우저 히스토리
    - POST 요청은 브라우저 히스토리에 남지 않음
4. 캐싱
    - POST 요청은 기본적으로 캐시할 수 없음
    - POST 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문

# HTTP response status code
- 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자
- 이 코드를 통해 요청이 성공했는지, 실패했는지, 추가적인 조치가 필요한지 즉시 파악 가능

### 403 Forbidden
- 서버에 요청이 전달되었지만, 권한 때문에 거절됨
- CSRF token이 누락됨

## CSRF
### Cross Site Request Forgery
- 사이트 간 요청 위조
- 사용자의 의지와는 무관하게 공격자가 의도한 행동을 특정 웹사이트에 요청하게 만드는 해킹 방식

### CSRF 공격의 방어
- Django는 공격을 막기 위해 CSRF 토큰이라는 안전장치를 사용
- 모든 중요한 요청에 대해 일회용 비밀 코드를 함께 보내도록 하여 위조된 요청을 막아줌

### CSRF Token 적용
```html
<!-- templates/articles/new.html -->

<h1>NEW</h1>
<form action ="{% url 'articles:create' %}" method="POST">
	{% csrf_token %}
```
- DTL의 csrf_token 태그를 사용해 쉽게 사용자에게 토큰 값을 부여
- 요청 시 토큰 값도 함께 서버로 전송될 수 있도록 함

### CSRF Token을 함께 보내야 하는 이유
- Django 서버는 해당 요청이 DB에 데이터를 하나 생성하는 요청에 대해 Django가 직접 제공한 페이지에서 데이터를 작성하고 있는 것인지에 대한 확인 수단이 필요
- 겉모습이 똑같은 위조 사이트나 정상적이지 않은 요청에 대한 방어 수단
- 요청 데이터 + 인증 토큰 -> 게시글 작성

# Redirect
### `redirect()`
```python
from django.shortcuts import render, redirect

def create(request):
    return redirect('articles:detail', article.pk)
```
- 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수

### `redirect` 동작 원리
1. `redirect` 응답을 받은 클라이언트는 detail url로 다시 요청을 보냄
2. 결과적으로 detail view 함수가 호출되어 detail view 함수의 반환 결과인 detail 페이지를 응답 받게 됨

# Delete
```python
# articles/views.py

def delete(request, pk):
    article = Article.objects.get(pk=pk)
    article.delete()
    return redirect('articles:index')
```

# Update
- 필요한 함수
    1. edit
        - 사용자 입력 데이터를 받을 페이지를 렌더링
    2. update
        - 사용자가 입력한 요청 데이터를 받아 DB에 저장

### edit
```python
# articles/views.py

def edit(request, pk):
    article = Article.objects.get(pk=pk)
    context = {
        'article': article,
    }
    return render(request, 'articles/edit.html', context)
```

### update
```python
# articles/urls.py

urlpatterns = [
    ...
    path('<int:pk>/update/', views.update, name='update'),
]
```
```python
# articles/views.py

def update(request, pk):
    article = Article.objects.get(pk=pk)
    article.title = request.POST.get('title')
    article.content = request.POST.get('content')
    article.save()
    return redirect('articles:detail', article.pk)
```