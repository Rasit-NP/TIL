# Django REST Framework
# REST API
## API
### API
- Application Programing Interface
- 두 소프트웨어가 서로 통신할 수 있게 하는 매커니즘

### Web API
- 웹 서버 또는 웹 브라우저를 위한 API
- 현대 웹 개발은 하나부터 열까지 직접 개발하기 보다 여러 Open API들을 활용

## REST API
### REST API 정의
- REST
    - Representational State Transfer
    - API Server를 개발하기 위한 소프트웨어 설계 방법
- RESTful API
    - "자원을 정의"하고 "자원에 대한 주소를 지정"하는 전반적인 방법을 서술

### REST에서 자원을 정의하고 주소를 지정하는 방법
- 자원의 식별
    - URI
- 자원의 행위
    - HTTP Methods
- 자원의 표현
    - JSON 데이터

## JSON 데이터 응답
### Python으로 JSON 데이터 처리하기
```python
import requests
from pprint import pprint

response = requests.get('http://127.0.0.1:8000/api/v1/articles/')
result = response.json()

print(type(result))
pprint(result)
```

# DRF with Single Model
## Django REST Framework
### DRF
- Django REST Framework
- Django에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리
- 복잡한 API 서버 개발 과정을 표준화하고 자동화

## Serializer
### Serialization
- 직렬화
- 여러 시스템에서 활용하기 위해 데이터 구조나 객체 상태를 재구성할 수 있는 포맷으로 변환하는 과정
- 변환된 데이터는 다른 프로그램, 다른 언어, 다른 컴퓨터에서도 다시 원래의 구조로 복원할 수 있음
- Serailizer
    - Serialization을 진행하여 Serialized data를 반환해주는 클래스
- Model Serializer
    - Django 모델과 연결된 Serializer 클래스
    - 일반 Serializer와 달리 사용자 입력 데이터를 받아 자동으로 모델 필드에 맞추어 Serialization을 진행

### ModelSerializer class 예시
```python
from rest_framework import serializers
from .models import Article

class ArticleSerializer(serializers.ModelSerializer):
		class Meta:
				model = Article
				fields = '__all__'
```

# CRUD with ModelSerializer
### URL과 HTTP requests methods 설계
- URL에 동작명(get, create)를 넣지 말고, 자원 중심으로 설계
- 깊은 중첩 구조는 피하고, 필요한 경우 관계를 명확히 표현
- 기능이 아닌 자원의 위치만 URL로 표현하고, 동작은 HTTP 메서드로 구분

## GET method - 조회
### GET - List
- 게시글 데이터 목록을 제공하는 ArticleListSerializer 정의
    ```python
    # articles/serializers.py

    from rest_framework import serializers
    from .models import Article

    class ArticleListSerializer(serializers.ModelSerializer):
            class Meta:
                    models = Article
                    fields = ('id', 'title', 'content')
    ```
- url 및 view 함수 작성
    ```python
    # articles/views.py

    from rest_framework.response import Response
    from rest_framework.decorators import api_view

    from .models import Article
    from .serializers import ArticleListSerializer

    @api_view(['GET'])
    def article_list(request):
            articles = Article.objects.all()
            serializer = ArticleListSerializer(articles, many=True)
            return Response(serializer.data)

    # articles/urls.py
    urlpatterns = [
            path('articles/', views.article_list),
            ...
    ]
    ```

### ModelSerializer의 인자 및 속성
- many 옵션
    ```python
    serializer = ArticleListSerializer(articles, many=True)
    ```
    - Serialize 대상이 QuerySet인 경우 입력
    - many 옵션을 지정하지 않으면 단일 객체로 처리됨
- data 속성
    ```python
    return Response(serializer.data)
    ```
    - Serialized data 객체에서 실제 데이터를 추출

### `api_view` decorateor
- DRF view 함수에서는 필수로 작성되면 view 함수를 실행하기 전 HTTP 메서드를 확인
- 허용하도록 지시한 메서드에 대해서만 올바르게 답변하며, 목록에 추가하지 않은 다른 메서드 요청에 대해서는 `405 Method Not Allowed`로 응답
- DRF view 함수가 응답해야 하는 HTTP 메서드 목록을 작성

### GET - Detail
- 단일 게시글 데이터 조회하기
    ```python
    # articles/serializers.py

    from rest_framework import serializers
    from .models import Article

    class ArticleSerializer(serializers.ModelSerializer):
            class Meta:
                    model = Article
                    fields = '__all__'
    ```
    - 각 게시글의 상태 정보를 제공하는 ArticleSerializer 정의
- url 및 view 함수 작성
    ```python
    # articles/urls.py

    urlpatterns = [
            ...
            path('articles/<int:article_pk>/', views.article_detail),
    ]

    # articles/views.py
    from .serializers import ArticleListSerializer, ArticleSerializer

    @api_view(['GET'])
    def article_detail(request, article_pk):
            article = Article.objects.get(pk=article_pk)
            serializer = ArticleSerializer(article)
            return Response(serializer.data)
    ```

## POST method - 생성
### POST
- 게시글 데이터 생성하기
    1. 데이터 생성이 성공했을 경우 `201_CREATED` 응답
    2. 데이터 생성이 실패했을 경우 `400_BAD_REQUESTED` 응답
- article_list view 함수 구조 변경(method에 따른 분기 처리)
    ```python
    # articles/views.py
    from rest_framework import status

    @api_view(['GET', 'POST'])
    def article_list(request):
            if request.method == 'GET':
                    articles = Article.objects.all()
                    serializer = ArticleListserializer(articles, many=True)
                    return Response(serializer.data)
            elif request.method == 'POST':
                    serializer = ArticleSerializer(data=requets.data)
                    if serializer.is_valid():
                            serializer.save()
                            return Response(serializer.data, status=status.HTTP_201_CREATED)
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    ```

## DELETE method - 삭제
### DELETE
- 게시글 데이터 삭제하기
    ```python
    # articles/views.py

    @api_view(['GET', 'DELETE'])
    def article_detail(request, article_pk):
            article = Article.objects.get(pk=article_pk)
            if request.method == 'GET':
                    serializer = ArticleSerializer(article)
                    return Response(serializer.data)
            
            elif request.method == 'DELETE':
                    article.delete()
                    return Response(status=status.HTTP_204_NO_CONTENT)
    ```
    - 요청에 대한 데이터 삭제가 성공했을 경우는 `204_NO_CONTENT` 응답
### DELETE 응답 시 Response 구성 방식
- `Response()`는 기본적으로 data 인자를 필요로 하지 않음
- 아무런 데이터도 넘기지 않을 경우엔 응답 상태 코드만으로 결과를 전달
    - 첫 번째 인자를 비운 상태로 두 번째 인자에 값을 전달할 수 없으므로, 키워드 인자 형태로 값 전달

### DELETE 응답 시 데이터를 반환하는 방법
- 일반적으로 DELETE 요청은 204 No Content로 본문 없이 응답하는 것이 RESTful한 설계방식
- 하지만 특정 상황에서는 삭제된 객체의 정보를 함께 반환해야 할 수도 있음
    - 클라이언트에서 삭제 대상 데이터를 확인하거나, UI에서 알림 메시지로 활용할 경우
    - 삭제된 데이터가 실제로 무엇이었는지 사용자에게 피드백을 주기 위해
- DELETE에서도 응답이 필요한 경우엔 204 대신 200 OK 상태 코드와 함께 데이터를 반환
    - 단, REST 원칙상 기본은 응답 없음(204) 이므로, 목적이 명확할 때만 사용

### DELETE 처리 후, 추가 응답 데이터 반환
```python
# articles/views.py

@api_view(['GET', 'DELETE'])
def article_detail(request, article_pk):
		article = Article.objects.get(pk=article_pk)
		...
		elif request.method == 'DELETE':
				pk = article.pk
				title = article.title
				article.delete()
				data = {
						'message': f'{pk}번 게시글 "{title}"이 삭제되었습니다.'
				}
				return Response(data, status=status.HTTP_200_OK)
```
- 게시글 데이터를 삭제하고, 삭제된 게시글 정보 반환
    - 추가적인 데이터를 제공하므로 200 OK 응답
- 반환할 데이터 정의
    - delete() 실행 시, 해당 객체는 데이터베이스에서 삭제됨
    - 그러므로 필요한 값은 삭제 전에 미리 변수로 저장해둠
    - 삭제 이후에는 변수만 사용하는 것이 더 안정적
- Response의 첫번째 인자로 전달

## PUT method - 수정
```python
# articles/views.py

@api_view(['GET', 'DELETE', 'PUT'])
def article_detail(request, article_pk):
		...
		elif request.method == 'PUT':
				serializer = ArticleSerializer(article, data=request.data)
				# serializer = ArticleSerializer(instance=article, data=request.data, partial=False)
				if serializer.is_valid(raise_exception=True):
						serializer.save()
						return Response(serializer.data)
				return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```
- 게시글 데이터 수정하기
    - 요청에 대한 데이터 수정이 성공했을 경우는 `200_OK` 응답

### `partial` argument
- “부분 업데이트”를 허용하기 위한 인자
- partial 인자의 기본 값은 False
- partial 인자를 False로 설정하면, 게시글의 title만 수정하려고 하더라도 content와 같은 다른 필수 필드들도 함께 전송해야 함
- 이는 serializer가 기본적으로 모든 필수 필드에 대한 값이 전달되었는지 확인하기 때문
- 따라서 일부 필드만 수정하고 싶다면, partial=True로 설정하여 일부 필드만 전달되도록 허용해야 함

### PATCH 메서드 - 일부 필드만 수정하기
```python
# articles/views.py

@api_view(['GET', 'DELETE', 'PATCH'])
def article_detail(request, article_pk):
		...
		elif request.method == 'PATCH':
				serializer = ArticleSerializer(article, data=request.data, partial=True)
				if serializer.is_valid(raise_exception=True):
						serializer.save()
						return Response(serializer.data)
				return Response(serialier.errors, status=status.HTTP_400_BAD_REQUEST)
```
- PATCH는 리소스의 전체가 아닌, 일부만 수정할 때 사용하는 HTTP 메서드
- Django REST Framework에서는 `partial=True` 설정을 통해 부분 수정을 구현
    - 게시글의 title만 바꾸고 싶을 때, 전체 필드를 다 보낼 필요 없이 해당 필드만 전송하면 됨

## GET  method

### GET - List

- 댓글 목록 조회를 위한 CommentSerializer 정의
    
    ```python
    # articles/serializers.py
    
    from .models import Article, Comment
    
    class CommentSerializer(serializers.ModelSerializer):
    		class Meta:
    				model = Comment
    				fields = '__all__'
    ```
    
- url 작성
    
    ```python
    # articles/urls.py
    
    urlpatterns = [
    		...,
    		path('comments/', views.comment_list),
    ]
    ```
    
- view 함수 작성
    
    ```python
    # articles/views.py
    
    from .models import Article, Comment
    from .serializers import ArticleListSerializer, ArticleSerializer, CommentSerializer
    
    @api_view(['GET'])
    def comment_list(request):
    		comments = Comment.objects.all()
    		serializer = CommentSerializer(comments, many=True)
    		return Response(serializer.data)
    ```
    

### GET - Detail

- 단일 댓글 조회를 위한 url 및 view 함수 작성
    
    ```python
    # articles/urls.py
    
    urlpattenrs = [
    		...,
    		path('comments/<int:comment_pk>/', views.comment_detail),
    ]
    
    # articles/views.py
    
    @api_view(['GET'])
    def comment_detail(request, comment_pk):
    		comment = Comment.objects.get(pk=comment_pk)
    		serializer = CommentSerializer(comment)
    		return Response(serializer.data)
    ```
    

## POST method

### POST

- 단일 댓글 생성을 위한 url 및 view 함수 작성
    
    ```python
    # articles/urls.py
    
    urlpattenrs = [
    		...,
    		path('articles/<int:article_pk>/comments/', views.comment_create),
    ]
    
    # articles/views.py
    
    @api_view(['POST'])
    def comment_create(request, article_pk):
    		article = Article.objects.get(pk=article_pk)
    		serializer = CommentsSerializer(data=request.data)
    		if serializer.is_valid(raise_exception=True):
    				serializer.save(article=article)
    				return Response(serializer.data, status=status.HTTP_201_CREATED)
    ```
    
- serializer 인스턴스의 save() 메서드는 특정 Serializer 인스턴스를 저장하는 과정에서 추가 데이터를 받을 수 있음
    
    ```python
    # articles/views.py
    
    @api_view(['POST'])
    def comment_create(request, article_pk):
    		article = Article.objects.get(pk=article_pk)
    		serializer = CommentSerializer(data=request.data)
    		if serializer.is_valid(raise_exception=True)
    				serializer.save(article=article)
    				return Response(serializer.data, status=status.HTTP_201_CREATED)
    ```
    
- CommentSerializer에서 외래 키에 해당하는 article field가 사용자로부터 입력받도록 설정되어 있어 서버측에서는 누락함
    - 유효성 검사 목록에서 제외 필요
    - article field를 읽기 전용 필드로 설정
- 데이터를 전송 받은 시점에 유효성 검사를 제외시키고, 데이터 조회 시에는 출력하도록 수정
    
    ```python
    # articles/serializer.py
    
    class CommentSerializer(serializers.ModelSerialier):
    		class Meta:
    				model = Comment
    				fields = '__all__'
    				read_only_fields = ('article',)
    ```
    

## 읽기 전용 필드

### 읽기 전용 필드

- 서버가 조회 요청에 대한 응답 시에만 값을 표시하는 필드
- 클라이언트가 입력해서는 안되는 필드를 응답 전용 필드로 지정할 때 사용

### 읽기 전용 필드 사용 목적

- 클라이언트 측에서 직접 수정하면 안 되는 경우
- 서버 로직에 의해 자동 생성$\cdot$관리되는 값 활용
- 입력은 받지 않지만 정보를 제공해야 하는 경우
- 새로운 필드 값을 만들어 제공해야 하는 경우

### 읽기 전용 필드 특징 및 주의사항

- 유효성 검사에서 제외됨
    - 읽기 전용 필드는 클라이언트가 보내는 요청 데이터에서 고려되지 않으므로, 유효성 검사 대상에서 제외됨
    - 즉, 클라이언트가 해당 필드에 값을 넣어도 무시되며 검증 오류를 일으키지 않음
- 생성$\cdot$수정 요청 모두에서 적용 가능
    - 읽기 전용 필드라 해서 생성(POST) 단계에서만 무의미한 것은 아님
    - 수정(PUT) 요청에서도 해당 필드는 여전히 클라이언트 입력을 받지 않고, 응답 시에만 노출됨

## DELETE & PUT method

### DELETE & PUT

- 단일 댓글 삭제 및 수정을 위한 view 함수 작성
    
    ```python
    # articles/views.py
    
    @api_view(['GET', 'PUT', 'DELETE'])
    def comment_detail(request, comment_pk):
    		comment = Comment.objects.get(pk=comment_pk)
    		if request.method == 'GET':
    				serializer = CommentSerializer(comment)
    				return Response(serializer.data)
    		
    		elif request.method == 'PUT':
    				serializer = CommentSerializer(comment, data=request.data)
    				if serializer.is_valid(raise_exception=True):
    						serializer.save()
    						return Response(serializer.data)
    		
    		elif request.method == 'DELETE':
    				comment.delete()
    				return Response(status=status.HTTP_204_NO_CONTENT)
    ```
    

## 응답 데이터 재구성

### 댓글 조회 시 게시글 출력 내역 변경

- 댓글 목록 조회 시 게시글 번호만 제공해주는 것이 아닌 **게시글의 제목**까지 제공하기
- Comment 모델은 Article을 참조하고 있음
    
    ```python
    # articles/models.py
    
    class Comment(models.Model):
    		article = models.ForeignKey(Article, on_delete=models.CASCADE)
    		...
    ```
    
    - Comment가 article과 N:1 관계를 맺고 있고, Django는 기본적으로 이 관계를 통해 숫자(id) 값만 응답에 포함
- CommentSerializer는 Comment의 정보를 가지고 있음
    
    ```python
    # articles/serializers.py
    
    class CommentSerializer(serializers.ModelSerializer):
    		class Meta:
    				model = Comment
    				...
    ```
    
    - Comment 모델이 Article을 참조하고 있어, 그 정보를 id로 field에 제공할 수 있음
- Serializer는 DRF에서 응답 구조를 결정하는 주체
    - Serializer를 통해 어떤 필드를 포함할 지 직접 지정하여 사용하고 있음
    - 또한 특정 필드를 어떤 형식으로 보여줄지도 지정하여 사용할 수 있음
    - 즉, article 필드가 “id가 아닌 게시글의 제목”을 보여주도록 지정할 수도 있음
- 하지만, CommentSerializer는 Comment의 정보만 가지고 있을 뿐, Article에 대한 정보는 없음
    
    ```python
    # articles/serializers.py
    
    class ArticleTitleSerializer(serializers.ModelSerializer):
    		class Meta:
    				models = Article
    				fields = ('title',)
    ```
    
    - article의 정보를 포함하고 있고, 그 중 title 필드의 정보만 반환하는 Serializer를 별도로 정의해야 함
- ArticleTitleSerializer의 적용
    - CommentSerializer에서만 사용할 용도라면, 굳이 독립적으로 선언할 필요 없음
    - 코드의 응집도를 높이고, 명확한 범위를 지정하기 위해서 CommentSerializer 내부에 정의
- Comment 모델의 article 필드를 ArticleTitleSerializer로 재정의
    
    ```python
    # articles/serializers.py
    
    class CommentSerializer(serializers.ModelSerializer):
    		class ArticleTitleSerializer(serializers.ModelSerializer):
    				class Meta:
    						model = Article
    						fields = ('title',)
    		
    		article = ArticleTitleSerializer(read_only=True)
    		
    		class Meta:
    				model = Comment
    				fields = '__all__'
    				# read_only_fields = ('article',)
    ```
    
    - 이제 article 필드는 게시글의 title 필드만 포함한 구조로 응답
    

## 읽기 전용 필드 주의 사항

- 특정 필드를 재정의 혹은 추가한 경우 read_only_fields는 동작하지 않음
- 이런 경우 새로운 필드에 read_only 키워드 인자로 작성해야 함

### `read_only_fields` 속성과 `read_only` 인자

- `read_only_fields`
    - 기존 외래 키 필드 값을 그대로 응답 데이터에 제공하기 위해 지정하는 경우
- `read_only`
    - 기존 외래 키 필드 값의 결과를 다른 값으로 덮어쓰는 경우
    - 새로운 응답 데이터 값을 제공하는 경우

# 역참조 데이터 구성

## 단일 게시글 + 댓글 목록

- Nested relationships (역참조 매니저 활용)
    
    ```python
    class ArticleSerializer(serializers.ModelSerializer):
    		class CommentDetailSerialzer(serializers.ModelSerializer):
    				class Meta:
    						model = Comment
    						fields = ('id', 'content',)
    		
    		comment_set = CommentDetailSerializer(many=True, read_only=True)
    		
    		class Meta:
    				model = Article
    				fields = '__all__'
    ```
    
    - 모델 관계 상으로 참조하는 대상(N)은 참조되는 대상(1)의 표현에도 포함되거나 중첩될 수 있음
    - Comment가 Article에 대한 정보를 article field를 사용하여 표현하였듯, Article은 자신을 참조하고 있는 comment들에 대한 정보를 역참조 매니저를 통해 표현할 수 있음

## 단일 게시글 + 댓글 개수

### 단일 게시글 조회 시, 댓글 개수도 함께 제공

- 기본적으로 게시글을 조회하면 참조 중인 댓글의 개수는 알 수 없음
    - Comment 모델과의 관계는 Article.comment_set으로 연결되지만, 댓글의 개수를 저장하는 별도 필드는 Article 모델에 정의한 적 없기 때문
- 따라서, 댓글 수를 응답하려면, 직접 계산해서 응답에 포함시켜야 함

### View 로직 개선: annotate

- View에서 Article 객체를 조회할 때 annotate를 활용해 num_of_comments 필드를 추가
    - annotate는 Django ORM 함수로, SQL의 집계 함수를 활용하여 쿼리 단계에서 데이터 가공을 수행
- 댓글 수를 세어 num_of_comments라는 필드를 추가
    
    ```python
    # articles/views.py
    
    @api_view(['GET', 'DELETE', 'PUT'])
    def article_detail(request, article_pk):
    		article = Article.objects.annotate(num_of_comments=Count('comment')).get(pk=article_pk)
    ```
    
    - serializer.data가 반환하는, article 객체에는 num_of_comments라는 **주석(annotate) 필드**가 포함되어 있음

### annotate를 사용하여 추가한 주석 필드를 serializer에 추가

- 단순히 `fields = '__all__'`만으로는 annotate된 필드가 포함되지 않음
    - annotate()는 실제 모델 필드를 생성하지 않음
    - annotate()는 쿼리 시점에만 존재하는 임시 필드를 추가하는 기능
    - 즉, Article 모델 클래스에는 num_of_coments라는 필드가 실제로 존재하지 않음
- `__all__`은 모델의 필드 기준으로 작동하기 때문에, annotate로 만들어진 필드는 여기에 포함되지 않음
- 이런 동적으로 계산된 필드를 응답에 포함하려면, SerializerMethodField를 사용해야 함

### Serializer 개선

```python
# articles/serializers.py

class ArticleSerializer(serializers.ModelSerializer):
		...
		num_of_comments = serializers.SerializerMethodField()
		
		class Meta:
				...
		
		def get_num_of_comments(self, obj):
				return obj.num_of_comments
```

- SerializerMethodField는 읽기 전용 필드를 커스터마이징 하는데 사용
- 이 필드를 선언한 뒤 `get_<필드 명>` 메서드를 정의하면, 해당 메서드의 반환 값이 직렬화 결과에 포함됨
- 이제 `serializer.data` 호출 시, `get_num_of_comments` 메서드가 실행되어 `num_of_comments` 값이 자동으로 응답할 데이터 필드에 포함되어 제공 됨
- 추가적으로 view에서 data를 딕셔너리로 변환하거나 수정할 필요 없이, `serializer.data`를 바로 반환해도 최종 JSON 응담에 `num_of_comments` 값이 반영됨

## SerializerMethodField

### SerializerMethodField

- Serializer에서 추가적인 데이터 가공을 하고 싶을 때 사용
- 특정 필드 값을 조합해 새로운 문자열 필드를 만들거나, 부가적인 계산을 하는 경우에 활용할 수 있음

### SerializerMethodField 동작 원리

```python
class UserSerializer(serializers.ModelSerializer):
		full_name = serializers.SerializerMethodField()
		
		class Meta:
				model = User
				fields = ('id', 'username', 'full_name', 'email',)
		
		def get_full_name(self, obj):
				return f'{obj.first_name} {obj.last_name}'
```

- SerializerMethodField를 Serializer 클래스 내에서 필드로 선언하면, DRF는 `get_<필드명>`이라는 이름을 가진 메서드를 자동으로 찾음
- 예를 들어, `full_name = serializers.SerializerMethodField()`라고 선언하면, DRF는 `get_full_name(self, obj)` 메서드를 찾아 해당 값을 직렬화 결과에 넣어 줌
- `obj`는 현재 직렬화 중인 모델 인스턴스이며, 이 메서드에서 `obj`의 속성이나 annotate된 필드를 활용해 새 값을 만들 수 있음

### SerializerMethodField 주의 사항

- 읽기 전용
- 생성, 수정 요청 시에는 사용되지 않음
- `get_` 메서드는 반드시 `(self, obj)` 형태로 정의해야 하며, obj는 현재 직렬화 중인 모델 인스턴스를 의미

### SerializerMethodField 사용 목적

- 유연성
    - 다양한 계산 로직을 손쉽게 추가 가능
- 가독성
    - 데이터 변환 과정을 Serializer 내부 메서드로 명확히 분리
- 유지보수성
    - view나 model에 비해 Serializer 측 로직 변경이 용이
- 일관성
    - view에서 별도로 data 수정 없이도 직렬화 결과를 제어

## 역참조 데이터 구성 참고

```python
# articles/models.py
class Comment(models.Model):
		article = models.ForeignKey(Article, on_delete=models.CASCADE, related_name='comments')
		...

# articles/views.py
@api_view(['GET', 'DELETE', 'PUT'])
def article_detail(request, article_pk):
		article = get_object_or_404(Article.objects.annotate(num_of_comments=Count('comments'), pk=article_pk))
```

- 만약, 역참조 매니저명을 변경하였다면, Serializer에서도 변경하여야 함