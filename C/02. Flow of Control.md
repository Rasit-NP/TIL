# Relational, Equality, and Logical Operators
## Relational Operators and Expressions
- 관계 연산자 `<`, `>`, `<=`, `>=`는 모두 이항 연산자
- 이 연산자들은 피연산자로 두 개의 항을 필요로 하며, 정수 값 `0`이나 `1`을 생성함
- `3 < j < 5`
    - 관계 연산자는 좌에서 우로 결합되므로 `(3 < j) < 5`와 같은 의미를 지님
    - `3 < j`와 `j < 5`를 동시에 검사하는 올바른 방법은 `3 < j && j < 5`임

## Equality Operators and Expressions
- 등가 연산자 `==`와 `!=`는 수식에 적용되는 이항 연산자
- 이 연산자들은 값이 `0`이나 `1`인 `int`형 정수를 반환

## Logical Operators and Expressions
- 논리 연산자 `!`는 단항 연산자, `&&`와 `||`는 이항 연산자
    - 수식에 사용될 경우, `int` 값 `0`이나 `1`을 생성

### Logical Negation
- 산술 또는 포인터형의 수식에 적용 가능
- 수식이 `0` 값을 가지면 `int` 값 `1`을 생성
- 수식이 `0`이 아닌 값을 가지면 `int` 값 `0`을 생성
- 논리에서의 `not`과 다름
    - `not(not(s)) = s`
    - `!(!(5)) = 1`

### `&&`, `||`
- 논리 부정과 마찬가지로 `0` 또는 `1`을 생성
- `&&`의 우선순위는 `||`보다 높음
- 두 연산자 모두 단항, 산술, 관계 연산자보다 우선순위가 낮음

### Short-circuit Evaluation
- `&&`와 `||`의 피연산자인 수식을 평가할 때, 전체 수식의 값이 참이나 거짓으로 결정됨과 동시에 평가 과정은 멈춤
- `expr1 && expr2`
    - `expr1`이 `0` 값을 갖는다면, `expr2`는 계산되지 않음
- `expr1 || expr2`
    - `expr1`이 `1` 값을 갖는다면, `expr2`는 계산되지 않음

# The Compound Statement
```C
{
    a += b += c;
    printf("a = %d, b = %d, c = %d\n", a, b, c);
}
```
```C
{
    a = 1;
    {
        b = 2;
        c = 3;
    }
}
```
- 중괄호 `{}`로 묶여진 선언문과 문장
- 주된 용도는 문장들을 실행 가능한 하나의 단위로 그룹화하는 것
- 선언문이 복합문의 시작 부분에 있으면, 그 복합문을 **블록**이라고도 함

# The Expression and Empty Statement
```C
a = b;
a + b + c;
;
printf("%d\n", a);
```
### The Expression Statement
- 수식 다음에 세미콜론 `;`이 붙은 것
- 세미콜론은 수식을 문장으로 만듦
- 각 문장은 다음 문장으로 넘어가기 전에 완전히 평가되어야 함

### The Empty Statement
- 공백 문장은 하나의 세미콜론으로 작성됨
- 구문상으로는 문장이 필요하지만, 의미상으로 그 문장이 필요 없을 때 유용함
- 특별한 수식 문장으로 볼 수 있음

# The `if` and the `if-else` Statements
### `if`
```C
if (expr)
    statement
```
- `expr`이 `0`이 아니면, `statement`가 실행됨
    - `0`이면 실행되지 않고 다음 문장으로 제어가 넘어감
- 일반적으로 `if`문에 있는 수식은 관계 수식, 등가 수식, 논리 수식 중 하나임
    - 그러나, 구문에 의하면, 어떤 수식이라도 허용될 수 있음
- 한 `if` 수식의 제어 아리에서 여러 문장을 수행해야 할 때에는 복합문을 사용

### `if-else`
```C
if (expr)
    statement1
else
    statement2
```
- `expr`이 `0`이 아니면, `statement1`이 실행되고 `statement2`는 실행되지 않음
    - `expr`이 `0`이면, `statement1`은 건너뛰고 `statement2`가 실행됨
- `if`문은 그 자체가 하나의 문장이기 때문에, 다른 `if`문의 `statement` 부분으로 사용될 수 있음

# The `while` Statement
```C
while (expr)
    statement
next statement
```
- `expr`의 값이 `0`이 아니면, `statement`가 실행되고, 제어는 `while` 루프의 시작 부분으로 다시 전달 됨
    - 이를 `expr`이 `0`이 될 때까지 반복 수행
    - `expr`이 `0`이 되면, 제어는 `next statement`로 넘어감
- 하나의 공백 문장만을 갖는 `while` 루프가 필요할 때도 있음
    ```C
    while ((c = getchar()) == ' ')
        ;
    ```
    - 입력 스트림에서 공백 문자를 무시하는 것이 가능

# The `for` Statement
```C
for (expr1; expr2; expr3)
    statement
next statement
```
- 위 구조는 아래와 같음
    ```C
    expr1;
    while (expr2){
        statement
        expr3;
    }
    next statement
    ```
- 먼저 `expr1`을 평가
    - 일반적으로 `expr1`은 루프를 초기화하는 데 사용됨
- `expr2`를 평가
    - 그 결과 `0`이 아니라면 `statement`를 실행하고 `expr3`을 평가
- `for` 루프의 처음으로 돌아가지만, `expr1`은 평가되지 않음
- 일반적으로 `expr2`는 반복 동작을 제어하는 논리 수식
- `expr1`이 생략됐다면, `for` 루프의 초기화 단계는 수행되지 않음
- `expr2`가 사용되지 않으면, `for` 문의 루프 반복을 위한 조건 검사는 항상 참

# The Comma Operator
```C
expr1, expr2
```
- 피연산자로 수식을 갖는 이항 연산자
- C의 모든 연산자들 중에서 가장 낮은 우선 순위를 가짐
- 먼저 `expr1`이 평가되고, 그 다음 `expr2`가 평가됨
- 콤마 연산자는 종종 `for`문에서 사용됨
    ```C
    for (sum = 0, i = 1; i <= n; ++i)
        sum += i;
    
    for (sum = 0, i = 1; i <= n; sum += i, ++i)
        ;
    ```

# The `do` Statement
```C
do
    statement
while (expr);
next statement
```
- `while`문의 변형된 형태
- `while`문과 다르게 루프의 하단에서 조건 검사를 함
- 먼저 `statement`가 실행되고 `expr`이 평가됨
- 만일 `expr`의 값이 `0`이 아니면, 제어는 `do`문의 시작 부분으로 다시 전달되고 반복됨
    - `expr` 값이 `0`이면, 제어는 `next statement`로 넘어감

# The `goto` Statement
```C
goto label;
label: exit(1);
```
- `goto`문은 현대 프로그래밍 방법론에서 유해한 구조로 여겨짐
- 현재 함수 내의 레이블이 붙은 문장으로 무조건 분기할 수 있게 함
    - 따라서 다른 제어 흐름 메커니즘(`for`, `while`, `do`, `if`, `switch`)들이 제공하는 유용한 구조를 파괴함
- label의 적용 범위는 label이 정의된 함수 내
- `goto` 문장을 사용하면, 제어는 조건 없이 label이 붙은 문장으로 전달됨
- 일반적으로 `goto`의 사용은 피해야 하고 전혀 필요 없음
    - 구조적 언어에서 `goto`문을 이용하여 제어의 흐름을 변경하는 방법은 불필요함
    - 다만 특별한 경우에 문서화가 잘 된 `goto`문은 프로그램을 효율적으로 만들 수 있음
    - 여러 단계로 중첩된 내부 루프에서 특별한 값을 검사하고 그 값이 발견되었을 때 프로그램의 제어를 함수의 가장 바깥 수준으로 분기할 경우에 사용될 수 있음

# The `break` and `continue` Statements
```C
break;
continue;
```
- 정상적인 제어의 흐름을 중단시킴
- `break`는 루프의 내부나 `switch`문으로부터 빠져 나오는데 사용됨
    - `break`를 사용하여 무한 루프를 종료할 수 있음
- `continue`는 루프의 현재 반복을 멈추고 즉시 다음 반복을 하게 함
    - `for`, `while`, `do` 루프 내에서만 사용됨

# The `switch` Statement
```C
switch (c){
    case 'a':
        ++a_cnt;
        break
    case 'b':
    case 'B':
        ++b_cnt;
        break;
    default:
        ++other_cnt;
}
```
- 키워드 `switch` 다음에 오는 괄호 안의 제어 수식은 반드시 정수적형 이어야 함
- 수식이 평가된 후, 제어는 해당되는 `case` label로 분기함
- 만일 `break` 문이 없다면, 다음 `case`에 속하는 바로 다음 문장이 실행됨
- 제어 수식에 해당하는 `case` label이 없는 경우 `default` label로 분기함
    - `switch`문에는 하나의 `default` label이 있을 수 있음
    - 어느 곳에든 올 수 있지만, 일반적으로 마지막 부분에 옴

# The Conditional Operator
```C
expr1 ? expr2 : expr3
```
- 3개의 수식을 피연산자로 갖는 삼항 연산자
- `expr1`의 값이 `0`이 아니면 `expr2`가 평가됨
    - `expr1`이 `0`이면 `expr3`이 평가됨
- 따라서 조건부 수식은 `if-else`문과 동일한 작업을 수행할 수 있음