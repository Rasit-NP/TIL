# Function Definition
```C
type function(parameter list){
    declarations
    statements
}
```
- `type`은 컴파일러에게 함수가 리턴하는 값을 알려줌
- `paramenter list`는 컴파일러에게 이 함수가 갖는 인자들을 알려줌
- 함수를 사용하여, 여러 개의 문장을 한 문장으로 줄여서 사용할 수 있음
- 함수의 몸체 안에 선언된 변수를 그 함수에 **지역적**이라고 함
- 함수 외부에 선언된 변수를 **전역 변수**라고 함
- 전통적인 C에서, 함수 정의는 매개변수 목록에 있는 변수들의 선언은 매개변수 목록과 첫 번째 중괄호 사이에 위치했음
    ```C
    void f(a, b, c, x, y)
    int a, b, c;
    double x, y;
    {
        ...
    }
    ```
- 함수들을 작성하는 이유
    - 한 가지 일만을 수행하는 작은 함수를 정확히 작성하는 것은 간단함
    - 프로그램의 작성이나 디버깅 모두를 쉽게 할 수 있음
    - 유지와 수정이 간단함
    - 작은 함수는 그 자체로 문서화가 되고, 이해하기도 쉬움

# The `return` Statement
- `return` 문을 만나면, 그 함수의 실행은 종료되고, 제어는 호출한 환경으로 넘어감
- 만일 `return` 문이 수식을 포함하고 있으면, 그 수식의 값도 호출한 환경으로 같이 넘어감
- 필요하다면, 그 수식의 값은 함수 정의에 명시된 함수의 형으로 변환됨
- `return` 문이 없다면, 제어는 함수 몸체의 닫는 중괄호를 만날 때 호출 환경으로 넘어감
- 함수가 값을 리턴하더라도, 프로그램은 그 값을 사용하지 않아도 됨

# Function Prototypes
```C
long pow(int, int);
```
- 함수는 사용되기 전에 선언되어야 함
- ANSI C는 새로운 함수 선언 구문인 **함수 원형**을 제공
- 함수 원형은 컴파일러에게 함수로 전달되는 인자의 수와 형 그리고 함수에 의해 리턴되는 값의 형을 알려줌
- 함수 원형을 선언한다면, 함수를 `main` 함수 아래에 작성해도 됨

# Function Declarations from the Compiler's Viewpoint
```C
int f(x)
double x;
{
    ...
}
```
```C
int f(double x){
    ...
}
```
- 전통적인 C 함수 선언의 경우
    - 컴파일러에게 함수의 선언과 정의를 모두 제공하지만
    - 매개변수로 `double` 형의 인자를 전달하는 것은 개발자의 책임
    - `f(1)`와 같이 호출한다면, 1은 `double`이 아닌 `int` 형이기 때문에 함수의 호출이 실패할 수 있음
- ANSI C 방식으로 함수를 선언할 경우
    - 컴파일러는 매개변수 목록에 대해 알 수 있음
    - `int` 형이 인자로 전달되면, `double`로 변환됨
- 좋은 프로그래밍 기법은 함수가 사용되기 전에 ANSI C 방식의 함수 선언이나 함수 원형 또는 둘 다를 먼저 제공하는 것
    - 표준 헤더 파일을 포함시키는 중요한 이유는 이 파일들이 함수 원형을 포함하고 있기 때문

### Limitations
- 함수 정의와 원형은 한계가 있음
- 함수의 기억 영역 클래스 명시자는 `extern`이나 `static` 중 하나일 수 있지만, 동시에 둘 다일 수는 없음
- '...의 배열' 또는 '...을 리턴하는 함수'와 같은 형은 함수에 의해 반환될 수 없음
    - 배열이나 함수의 포인터는 반환될 수 있음
- 매개변수 목록에 올 수 있는 기억영역 클래스 명시자는 `register` 뿐임
- 매개변수는 초기화 될 수 없음

# An Alternate Style for Function Definition Order
1. 첫 번째 방법
    - 파일의 제일 상단에 `# include`와 `# define`
    - 그 다음 열거형과 구조체와 공용체의 틀
    - 함수 원형
    - `main()` 함수부터 시작하여 다른 함수들의 정의
2. 두 번째 방법
    - 함수 원형들을 제거하고, 함수가 호출되기 전 부분에 함수 정의를 작성
    - 이런 경우 `main()` 함수는 파일의 맨 뒤에 위치하게 됨

# Function Invocation and Call-by-Value
- 함수를 호출하고 싶다면, 함수의 이름과 괄호로 둘러싸인 인자 목록을 쓰면 됨
- 모든 인자는 **값에 의한 호출**로 전달됨
- 이는 각 인자가 평가된 후, 그 값이 대응되는 형식 매개변수의 위치에서 지역적으로 사용됨을 의미함
- 따라서 변수가 함수로 전달되어도, 호출한 환경에 저장된 변수 값은 변경되지 않음
- **값에 의한 호출**과 상반되는 개념은 **참조에 의한 호출**
    - 이 방식은 변수의 주소를 호출된 함수로 전달하여 호출된 함수에서 호출한 환경의 변수 값을 바꿀 수 있게 함

### The Meaning of Function Invocation
1. 인자 목록의 각 수식이 평가됨
2. 필요하다면, 그 수식의 값이 형식 매개변수의 형으로 변환되고, 함수 몸체의 시작 부분에서 그 값이 대응되는 형식 매개변수에 할당됨
3. 함수의 몸체가 실행됨
4. `return`문을 만나면, 제어는 호출한 환경으로 넘어감
5. `return`문이 수식을 가지고 있다면, 필요한 경우 그 수식의 값이 함수의 형으로 변환된 다음 그 값도 호출한 환경으로 넘어감
6. `return`문이 수식을 가지지 않는다면, 어떠한 유용한 값도 호출한 환경으로 리턴되지 않음
7. `return`문이 없다면, 제어가 함수 몸체의 끝에 도달할 경우 호출한 환경으로 넘어감
8. 모든 인자는 **값에 의한 호출**로 넘어감

# Developing a Large Program
```C
/* pgm.h */

# include <stdio.h>
# include <stdlib.h>

# define N 3

void fct1(int k);
void fct2(void);
void prn_info(char *);
```
```C
/* main.c */

# include "pgm.h"

int main(void){
    int i, n=N;
    for (i=0; i<n; ++i)
        fct1(i);
    return 0;
}
```
```C
/* fct.c */

# include "pgm.h"

void fct1(int n){
    int i;
    for (i=0; i<n; ++i)
        fct2();
}
void fct2(void){
    ...
}
```
- 일반적으로 대형 프로그램은 별도의 디렉토리에 `.h` 파일과 `.c` 파일들로 작성됨
- 각 `.c` 파일은 하나 이상의 함수 정의를 포함하게 되고, 시간 절약을 위해 개별적으로 컴파일될 수 있음

# Using Assertions
```C
int f(int a, int b){
    ...
    assert(a==1 || a==-1);
    assert(b>=7 && b<=11);
}
```
- C 시스템은 개발자가 `assert()` 매크로를 사용할 수 있도록 하기 위해 표준 헤더 파일 `assert.h`를 제공
- 만일 `assert()`에 인자로 전달된 수식이 거짓이면, 시스템은 메시지를 출력하고 프로그램을 중단시킴
- 단정은 작성하기 쉽고, 프로그램을 정확히 작동하게 만들며, 프로그램의 작성 의도를 쉽게 이해할 수 있게 해줌

# Scope Rules
- 식별자는 그 식별자가 선언된 블록 안에서만 이용이 가능
- 즉, 식별자가 선언된 블록 밖의 영역에서는 그 식별자를 이요할 수 없음
- 외부 블록 이름은 내부 블록이 그것을 다시 정의하지 않는 한, 내부 블록에서도 유효함
- 만일, 다시 정의된다면, 외부 블록 이름은 내부 블록으로부터 숨겨짐

### Parallel and Nested Blocks
- 두 개의 블록이 차례대로 올 경우, 두 번째 블록은 첫 번째 블록에서 선언한 변수를 알 지 못함
- 같은 레벨에 있는 이러한 블록들을 **병렬 블록**이라고 함
- 병렬 블록과 중첩 블록은 임의의 복잡한 구조로 결합될 수 있음
- 블록을 사용하는 큰 이유는 변수를 위한 메모리를 필요할 때만 할당할 수 있게 하기 때문

# Storage Classes
- C의 모든 변수와 함수는 형과 기억영역 클래스 두 가지 속성을 가짐
    - 기억영역 클래스에는 `auto`, `extern`, `register`, `static`의 4가지 종류가 있음
    - 지금까지 본 것 중 가장 일반적인 기억영역 클래스는 `auto`
    - 네 클래스들은 모두 중요한 사용 용도가 있기 때문에, 개발자는 네 가지 기억 영역 클래스에 대해서 알고 있어야 함

### The Storage Class `auto`
```C
auto int a, b, c;
auto float f;
```
- 블록 안에서 선언된 변수는 묵시적으로 `auto` 기억영역 클래스
- 키워드 `auto`를 사용해 클래스를 명시할 수도 있음
- 블록을 들어갈 때, 시스템은 `auto` 변수들을 위해 메모리를 할당함
- 이러한 변수들은 블록 내에서 선언되고, 블록을 빠져나갈 때 시스템은 `auto` 변수를 위해 할당했던 메모리를 회수함
- 함수의 몸체가 선언을 포함하고 있으면, 함수 정의의 몸체는 하나의 블록으로 구성됨
- 만일 함수가 선언을 포함하고 있다면, 함수가 호출될 때마다 새로운 환경이 구성됨

### The Storage Class `extern`
```C
extern int a=1, b=2, c=3;
```
- 블록들과 함수들 간에 정보를 전달하는 방법은 외부 변수를 사용하는 것
- 변수가 함수 밖에서 선언되어 있다면, 이 변수의 기억영역 클래스는 `extern`이 되고, 프로그램이 종료될 때까지 메모리에 계속 남아 있게 됨
- 이러한 변수는 이 이후에 정의된 모든 함수에게 전역으로 생각되고, 블록이나 함수가 끝나더라도 외부 변수는 계속 존재함
- 함수 밖에서 선언된 변수들은 키워드 `extern`을 사용하지 않아도, `extern` 기억영역 클래스를 가짐
    - 이러한 변수들은 `auto`, `register` 클래스를 가질 수 없음
    - 키워드 `static`을 사용할 수는 있지만, 특별한 경우에만 사용함
- `extern` 키워드는 다른 파일의 변수를 찾을 때도 사용할 수 있음
    ```C
    /* file1.c */
    # include <stdio.h>

    int a = 1, b = 2, c = 3;
    int f(void);

    int main(void){
        printf("%d", f());
    }

    /* file2.c */
    int f(void){
        extern int a;
        int b, c;
        a = b = c = 4;
        return (a+b+c);
    }
    ```

### The Storage Class `register`
```C
{
    register int i;
    for (i=0; i < LIMIT; ++i){
        ...
    }
}
```
- 컴파일러에게 변수를 가능하다면 고속 메모리 레지스터에 저장되도록 함
- 컴파일러가 물리적인 레지스터를 할당하지 못할 경우, 디폴트로 `auto` 기억영역 클래스가 됨
- 기본적으로, `register` 클래스의 사용은 실행 속도를 증가시키기 위한 것임
    - 실행 속도가 중요한 문제일 때, 가장 많이 사용하는 변수 몇 개를 `register`가 되게 선언함
    - 일반적으로 루프 변수와 함수의 매개 변수에 적용함

### The Storage Class `static`
```C
void f(void){
    static int cnt=0;
    ++cnt;
    if (cnt % 2 == 0)
        ...
    else
        ...
}
```
- 기본적으로 블록에서 선언된 변수가 그 값을 계속 유지하도록 해, 그 블록에 다시 들어갈 때 그 변수의 이전 값을 사용할 수 있도록 하는 것
    - 이는 블록을 나갈 때 변수의 값을 상실하고 블록에 다시 들어갈 때 다시 초기화되는 일반적인 `auto` 변수와 대조적
- 함수가 종료된 후에, 다시 호출되어도 전에 호출되었던 마지막 값을 계속 유지함

# Static External Variables
```C
void f(void){
    ...         /* v is not available here */
}
static int v;
void g(void){
    ...         /* v can be used here */
}
```
```C
static int g(void);
void f(int a){
    ...
}
static int g(void){
    ...
}
```
- 외부 변수와 다르게 유효범위에 제한이 있는 변수
    - 정적 외부 변수의 유효범위는 자신이 선언되어 있는 원시 파일의 나머지 부분
    - 따라서 그 변수 이전에 선언된 함수나 다른 파일에서 선언된 함수는 그 변수를 사용할 수 없음
- 이러한 기능으로 특정한 함수에 대해서는 전역 변수가 되고, 다른 파일에는 비공개가 되는 변수를 지정할 수 있음
- `static`의 마지막 용도는 함수 정의와 원형을 위한 저장영역 클래스 명시자로 사용되는 것
    - 일반적인 함수는 다른 파일에서도 접근이 가능하지만, `static` 함수는 자신이 선언되어 있는 파일 내에서만 접근이 가능
    - 이 방식은 함수 정의를 비공개 모듈로 구현하는데 유용함

# Default Initialization
- C에서 `extern` 변수와 `static` 변수는 개발자가 초기화하지 않아도 시스템에 의해 0으로 초기화됨
- 이와 같은 방식으로 초기화되는 것에는 배열, 문자열, 포인터, 구조체, 공용체가 있음
- 반면에, `auto` 변수와 `register` 변수는 일반적으로 시스템에 의해 초기화되지 않음
    - 이러한 변수는 초기에는 가비지 값을 가짐을 의미함
- 어떤 C 시스템은 `auto` 변수를 0으로 초기화하기도 하지만, 이에 의지하면 안됨

# Recursion
```C
# include <stdio.h>

int main(void){
    main();
    return 0;
}
```
- 어떤 함수가 직간접적으로 자기 자신을 호출하는 것
- 대부분의 재귀적 함수는 반복적 함수로 다시 작성할 수 있음
    - 두 방식의 함수는 같은 값을 반환하지만, 반복적 함수는 전달되는 인자의 값에 상관없이 한 번의 함수 호출만 필요로 함

### Efficiency Considerations
- 많은 알고리즘은 재귀적 방식과 반복적 방식 둘 다로 표현할 수 있음
    - 전형적으로, 재귀가 더 간결하고, 같은 계산을 하는 데 더 적은 변수를 필요로 함
- 재귀는 인자와 변수를 **스택**에 쌓아 관리함
    - 인자를 스택에 쌓아 두는 것은 많은 시간과 공간을 요구함
- 재귀의 사용이 매력적으로 보이지만, 비효율성과 실행 시간의 제한을 염두해야 함