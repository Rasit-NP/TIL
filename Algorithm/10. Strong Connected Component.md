# SCC(Strong Connected Component)

## 개요
- 정의
    > 방향 그래프에서 두 정점 $w, v$가 서로 도달 가능(즉, $u\rightarrow v$도 가능하고 $v\rightarrow u$도 가능)하다면, 이 두 정점은 같은 강한 연결 요소(SCC)에 속한다고 말함
- 방향 그래프에서의 연결 구조를 분석하기 위한 핵심 개념
- 그래프를 **서로 완전히 연결된 덩어리**들로 나눈 것이 **SCC 분해**(Decomposition)
- 이 덩어리들(SCC)은 서로 방향성이 있어, 하나의 유향 비순환 그래프(DAG, Directed Acyclic Graph)로 축약할 수도 있음

## 기본 아이디어
-  Kosaraju 알고리즘
    1. DFS를 수행하여 방문 종료 순서를 기록
    2. 그래프의 모든 간선 방향을 뒤집은 그래프를 만듦
    3. 종료 순서의 역순으로 다시 DFS를 수행하면서, 각 탐색에서 방문되는 모든 노드를 하나의 SCC로 묶음
    - 이 알고리즘은 2번의 DFS로 SCC를 찾을 수 있음
    - 시간 복잡도는 $O(V+E)$(정점 수$V$, 간선 수 $E$)
- Tarjan 알고리즘
    - 각 노드에 아래 정보를 부여해 **한 번의 DFS**로 SCC를 찾을 수 있는 알고리즘
        - `ids[u]`
            - DFS에서 방문된 순서 번호
        - `low[u]`
            - 노드 `u`에서 역방향 간선을 따라 도달 가능한 가장 작은 `dfs_num`
        - DFS 도중, `low[u] == ids[u]`를 만족하는 시점이 나타나면, 스택에 쌓여 있던 노드들을 하나의 SCC로 묶음

## 예시 코드
```python
import sys
sys.setrecursionlimit(1<<20)

n, m = map(int, input().split())
graph = [[] for _ in range(n+1)]

for _ in range(m):
		a, b = map(int, input().split())
		graph[a].append(b)

id_counter = 0
ids = [0] * (n+1)
low = [0] * (n+1)
on_stack = [False] * (n+1)
stack = []
SCCS = []

def dfs(u):
		global id_counter
		id_counter += 1
		ids[u] = low[u] = id_counter
		stack.append(u)
		on_stack[u] = True
		
		for v in graph[u]:
				if ids[v] == 0:
						dfs(v)
						low[u] = min(low[u], low[v])
				elif on_stack[v]:
						low[u] = min(low[u], ids[v])
		
		# root node 발견
		if low[u] == ids[u]:
				scc = []
				while True:
						node = stack.pop()
						on_stack[node] = False
						scc.append(node)
						if node == u:
								break
				SCCs.append(scc)

for i in range(1, n+1):
		if ids[i] == 0:
				dfs(i)

for scc in SCCs:
		print(sorted(scc))
```

## 활용 팁 및 주의 사항
- 그래프 압축(Condensation Graph)
    - SCC를 하나의 노드로 압축하면 DAG(유향 비순환 그래프)가 됨
    - 위상 정렬 등에 활용 가능
- 2-SAT 문제 해결
    - 논리식에서 변수를 SCC로 분해해 만족 여부를 판별할 수 있음
- 순환 구조 탐지
    - 강한 연결 요소 중 크기가 1보다 큰 집합은 모두 사이클을 의미함
- 그래프는 **방향성**이 있는 경우에만 SCC 개념이 유효
- DFS 기반이므로, **재귀 깊이 초과**가 발생할 수 있음
- Kosaraju는 그래프를 두 번 탐색해야 하지만 구현이 직관적이고, Tarjan은 한 번만 탐색하지만 스택 관리가 중요

## 추가 정보
- SCC의 DAG화
    - SCC들을 하나의 노드로 축약하면, 원래의 그래프는 DAG가 됨
    - 이 구조는 그래프 위상 정렬, 의존성 분석, 패키지 설치 순서 계산 등에 사용됨
- 시간 복잡도
    - Kosaraju, Tarjan 모두 $O(V+E)$
    - 따라서 10만 개 이상의 노드에서도 충분히 사용할 수 있음
- 관련 알고리즘
    - 위상 정렬(Topological Sort)
    - 2-SAT 문제
    - SCC DAG 최단 경로(DP 활용)