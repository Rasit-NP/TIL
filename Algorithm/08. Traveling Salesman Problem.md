# TSP(Traveling Salesman Problem)

## 개요
> 한 외판원이 여러 도시를 방문해야 할 때, 모든 도시를 정확히 한 번 씩 방문하고 다시 출발 도시로 돌아오는 최소 비용 경로를 찾는 문제
- TSP는 **NP-hard** 문제로, 도시 수가 많아질 수록 모든 경우를 탐색하는 완전 탐색 방식은 현실적으로 불가능
- 다양한 알고리즘(DP, 분기 한정법)이 연구됨

## 기본 아이디어
- TSP의 핵심은 모든 도시를 한 번 씩 방문하고 최적 경로를 찾는 것
- 완전 탐색
    - 모든 순열을 만들어서 최소 비용 경로를 선택
    - 장점
        - 정확한 해
    - 단점
        - 도시 수가 많으면 $O(n)$로 비효율적
- DP + 비트마스크
    - 현재 위치와 방문한 도시 정보를 상태로 정의
    - `dp[현재 도시][방문한 도시 집합]` = 현재 상태에서 최적 경로 비용
    - 점화식
        $$dp[u][S] = \min_{v\notin S}(dp[v][S\cup{v}] + cost[u][v])$$

## 예시 코드
```python
n = 4
INF = float('inf')

# 예시 거리 행렬
cost = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

# dp[node][visited] = 최소 비용
dp = [[INF] * (1<<n) for _ in range(n)]

def tsp(node, visited):
		# 모든 도시 방문 후 시작점으로 돌아가기
		if visited == (1 << n) - 1:
				return cost[node][0] if cost[node][0] > 0 else INF
		
		if dp[node][visited] != INF:
				return dp[node][visited]
		
		for next_city in range(n):
				if not visited & (1 << next_city) and cost[node][next_city] > 0:
						dp[node][visited] = min(
								dp[node][visited],
								tsp(next_city, visited | (1 << next_city)) + cost[node][next_city]
						)
				return dp[node][visited]

# 0번 도시에서 출발
result = tsp(0, 1 << 0)
print(result)
```
- `visited`는 현재까지 방문한 도시를 비트로 표현
- 각 도시에서 방문하지 않은 도시로 이동하여 최소 비용을 계산
- 메모이제이션으로 중복 계산 방지

## 활용 팁 및 주의 사항
1. 도시 수가 적으면 DP + 비트마스크로 해결 가능
    - 일반적으로 `n<=20` 정도가 실용적
2. 도시 수가 많으면 근사 알고리즘 사용
    - 그리디 알고리즘
    - 유전 알고리즘
    - 2-opt
    - Christofides 알고리즘
3. 완전 탐색 시 factorial 증가 주의
    - `n!`만큼 경우의 수가 폭발적으로 늘어남
4. 대칭성 확인
    - `cost[i][j] = cost[j][i]`일 경우 약간의 최적화 가능

### 추가 정보
- 문제 변형
    - 일부 도시만 방문(Partial TSP)
    - 경로 길이가 제한된 TSP
    - 시간창(time window)을 고려한 TSP
- 응용 분야
    - 물류, 배송, 경로 최적화
    - 칩 설계, DNA 시퀀싱
    - 로봇 경로 계획
- 참고 자료
    - "Introduction to Algorithms" - Cormen 외
        - Chapter 35