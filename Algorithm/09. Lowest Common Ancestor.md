# LCA(Lowest Common Ancestor)

## 개요
- 트리 구조에서 **두 노드의 가장 가까운 공통 조상**을 찾는 문제
    - 즉, 두 노드의 경로가 만나는 가장 아래쪽 조상 노드를 찾는 것이 목적
- 아래 내용을 이해해야 효율적으로 풀 수 있음
    - 트리의 깊이 관계
    - 조상으로의 점프
    - DP와 이진탐색

## 기본 아이디어
1. 단순한 방법($O(N)$)
    - 두 노드 `u`, `v`가 주어졌을 때,
        1. 각 노드의 부모를 차례로 따라 올라가면서 루트까지의 경로를 구함
        2. 두 경로에서 가장 마지막으로 일치하는 노드를 찾음
    - 위 방법은 쿼리마다 $O(N)$이 걸려서, 쿼리가 많을 때는 비효율적
2. 개선된 방법: Binary Lifting($O(N\log N)$ 전처리 + $O(\log N)$ 질의)
    - 핵심 아이이어
        - 모든 노드에 대해 "$2^i$ 번째 조상이 누구인가"를 미리 저장해두면, 조상을 $\log N$ 번 점프만으로 빠르게 올라갈 수 있음
        - `parent[x][i] = parent[parent[x][i-1]][i-1]`이라는 점화식을 사용해 모든 노드의 $2^i$ 번째 조상을 미리 계산
    - $LCA(u,v)$  찾는 과정
        1. 깊이(depth) 맞추기
            - 깊이가 더 깊은 쪽을 위로 올려서 두 노드의 깊이를 동일하게 맞춤
        2. 동시에 점프하며 조상 찾기
            - 두 노드가 같아질 때까지 큰 단위부터 조상을 비교하며 올림
        3. 마지막 부모가 공통 조상

## 예시 코드
```python
import sys
sys.setrecurtion(1<<20)
input = sys.stdin.readline

N = int(input())
LOG = 21    # (2^20 = 1,048,576 > N)
edges = [[] for _ in range(N+1)]
for _ in range(N-1):
		a, b = map(int, input().split())
		edges[a].append(b)
		edges[b].append(a)

parent = [[0]*LOG for _ in range(N+1)]
depth = [0]*(N+1)

def dfs(x, p):
		for y in edges[x]:
				if y != p:
						parent[y][0] = x
						depth[y] = depth[x] + 1
						dfs(y, x)
dfs(1, 0)

for i in range(1, LOG):
		for x in range(1, N+1):
				parent[x][i] = parent[parent[x][i-1]][i-1]

def lca(a, b):
		if depth[a] < depth[b]:
				a, b = b, a
		diff = depth[a] - depth[b]
		for i in range(LOG):
				if diff & (1<<i):
						a = parent[a][i]
		
		if a==b:
				return a
		
		for i in reversed(range(LOG)):
				if parent[a][i] != parent[b][i]:
						a = parent[a][i]
						b = parent[b][i]
		return parent[a][0]

Q = int(input())
for _ in range(Q):
		a, b = map(int, input().split())
		print(lca(a, b))
```

## 활용 팁 및 주의 사항
- 활용되는 분야
    - 트리 쿼리 문제
        - 두 노드 간 거리, 경로 가중치 계산
    - 네트워크 연결 구조 분석
    - 유전자 계보 추적 / 디렉터리 구조 탐색
    - Union-Find 확장 응용
- 주의 사항
    - `dfs()`로 부모와 깊이를 구할 때 재귀 깊이 제한을 넉넉히 설정해야 함
    - 트리 루트가 1이 아닐 수 있음
        - 입력에 따라 루트를 지정해야 함
    - `LOG`는 `ceil(log2(N)) + 1` 정도로 충분히 크게 설정해야 함
    - 쿼리가 많을 수록  $O(\log N)$  LCA가 압도적으로 효율적

## 추가 정보
- LCA 변형 문제
    - K번째 조상 찾기
        - LCA의 점프 테이블(`parent[][]`)을 그대로 사용
    - 두 노드 간 거리 계산
        - `dist(u, v) = depth[u] + depth[v] - 2*depth[LCA(u, v)]`
    - 가중 트리에서 거리 계산
        - LCA와 함께 `weight_sum[]` 배열을 유지
- 다른 알고리즘 비교
    - Tarjan의 오프라인 알고리즘
        - 쿼리가 미리 주어진 경우 빠름
    - 세그먼트 트리 기반 RMQ(Range Minimum Query)로도 LCA 계산 가능