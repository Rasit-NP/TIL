# KMP Algorithm

### 개요
- 문자열 검색 문제를 효율적으로 해결하기 위한 알고리즘
- 가장 단순한 Brute Force의 경우
    - 텍스트의 각 위치에서 패턴을 하나씩 맞춰보며 비교하는 방식
    - 최악의 경우 $O(N\times M)$ 시간이 걸림
- KMP 알고리즘은 이 과정을 $O(N+M)$으로 줄임
- 한 번 비교했던 문자를 다시 비교하지 않도록 **패턴 내부의 규칙**을 미리 이용하는 것이 핵심

### 기본 아이디어
1. 부분 일치 테이블(=Failure Function, LPS 배열)
    - Longest Prefix which is also Suffix
        - 현재 위치까지의 접두사 중에서, 접미사와 일치하는 최대 길이를 저장한 배열
    - P = "ABABAC"의 경우
        | 인덱스 | 문자 | LPS |
        | --- | --- | --- |
        | 0 | A | 0 |
        | 1 | B | 0 |
        | 2 | A | 1 |
        | 3 | B | 2 |
        | 4 | A | 3 |
        | 5 | C | 0 |
2. 실제 비교 과정
    - 텍스트를 탐색하면서 다음과 같은 규칙으로 비교를 진행
        1. 일치할 때
            - 두 포인터를 한 칸 씩 이동
        2. 불일치할 때
            - 패턴 포인터를 0으로 돌리지 않고, 이전까지 일치했던 부분의 LPS 정보를 참조하여 이동
    - 즉, 패턴의 처음부터 다시 비교하지 않고, 이미 일치했던 접두사-접미사 정보를 활용해 건너뜀

### 예시 코드
```python
def compute_lps(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1

    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]    # 이전 접두사-접미사로 돌아감
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    n = len(text)
    m = len(pattern)
    lps = compute_lps(pattern)
    i = j = 0
    result = []

    while i < n:
        if text[i] == pattern[j]:
            i += 1
            j += 1
        
        if j == m:
            result.append(i - j)
            j = lps[j-1]
        elif i < n and text[i] != pattern[j]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1
    return result
```

### 활용 팁 및 주의 사항
- 활용 팁
    - 긴 문자열 검색에 매우 효율적
        - 웹 검색, DNA 서열 분석, 보안 문자열 탐색 등에서 자주 쓰임
    - 문자열 비교 횟수가 최소화됨
        - 이미 확인한 부분을 다시 보지 않기 때문에 성능이 뛰어남
    - 패턴이 반복적인 경우 특히 강력
- 주의 사항
    - LPS 배열 계산을 잘못하면 결과가 엉망
        - prefix, suffix의 정의를 명확히 이해해야 함
    - 공백, 대소문자, 특수문자 구분에 유의
        - 단순히 문자 단위로 비교하기 때문에, 입력 전처리가 중요
    - 비교 대상이 많을 경우 메모리 고려 필요
        - LPS 배열 크기는 패턴의 길이에 비례함

### 추가 정보
- 이름의 유래
    - 알고리즘의 고안자 세 명인 *Donald Knuth, Vaughan Pratt, JamesH. Morris*의 이름을 땀
- 비교 알고리즘
    - Naive 방법
        - $O(N\times M)$
    - Rabin-Karp
        - 해시 기반
        - 평균 $O(N+M)$
        - 최악 $O(N\times M)$
    - Boyer-Moore
        - 역방향 탐색으로 실무에서는 KMP보다 빠르기도 함