# Convex Hull

## 개요
- 평면 위에 주어진 점 집합을 모두 포함하는 **가장 작은 볼록 다각형**
    - 점들을 바닥에 놓고 고무줄로 감싼 뒤 놓을 때, 고무줄이 닿는 바깥쪽 점들의 집합
    - 내부에 있는 점들은 볼록 껍질을 구성하지 않음

### 수학적 정의
- 점 집합 $S \subset \mathbb{R}^2$에 대해, Convex Hull은 $S$를 포함하는 모든 볼록 집합의 교집합

### 주요 성질
- 결과는 **볼록 다각형**
- 꼭짓점(vertex)은 입력 점 중 일부
- 점의 개수가 $N$일 때, 껍질의 꼭짓점 개수는 최대 $N$

## 기본 아이디어
- Convex Hull을 구하는 알고리즘은 여러가지가 있음
- 실전에서 가장 많이 쓰이는 것은 **Graham Scan**과 **Monotone Chain**

### Graham Scan
- **기준점(anchor)** 하나를 선택
    - 보통 y 좌표가 가장 작고, 같으면 x가 가장 작은 점
- 나머지 점들을 기준점 기준으로 **극각(polar angle)** 순으로 정렬
- 정렬된 점들을 순서대로 보면서
    - **시계 방향** 회전이 발생하면 이전 점 제거
    - **반시계 방향** 회전이면 유지
- 시간 복잡도
    - 정렬 : $O(N \log{N})$
    - 스캔 : $O(N)$
- 특징
    - 개념적으로 직관적
    - 각도 정렬이 필요하여 구현이 다소 까다로움

### Monotone Chain (Andrew Algorithm)
- 모든 점을 **x좌표** $\rightarrow$ **y좌표** 순으로 정렬
- 정렬된 점으로
    - 점을 왼쪽에서 오른쪽으로 보며 **아래 껍질(lower hull)** 구성
    - 점을 오른쪽에서 왼쪽으로 보며 **윗 껍질(upper hull)** 구성
    - 각 점에서 **CW 회전이 생기면 제거**
- 두 껍질을 합쳐 Convex Hull 완성
- 시간 복잡도
    - 정렬 : $O(N \log{N})$
    - 나머지 : $O(N)$
- 특징
    - 구현이 단순하고 안정적

### CCW 판정
- 세 점 $A, B, C$에 대해,
$$CCW(A, B, C) = (x_B - x_A)(y_C-y_A) - (y_B-y_A)(x_C-x_A)$$
- CCW > 0 : 반시계
- CCW < 0 : 시계
- CCW = 0 : 일직선

## 예시 코드
### Graham Scan
```cpp
# include <bits/stdc++.h>
using namespace std;

struct Point{
		long long x, y;
};

bool operator<(const Point& a, const Point& b){
    if (a.y != b.y) return a.y < b.y;
    return a.x < b.x;
}

// CCW 판정 (양수: 반시계, 음수: 시계, 0: 일직선)
long long ccw(const Point& A, const Point& B, const Point& C){
    return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}

long long dist2(const Point& A, const Point& B){
    long long dx = A.x - B.x;
    long long dy = A.y - B.y;
    return dx*dx + dy*dy;
}

vector<Point> convexHull(vector<Point>& pts){
    int n = (int)pts.size();
    if (n<=1) return pts;
    
    // 기준점 찾기
    int p0_idx = 0;
    for (int i = 1; i < n; ++i){
        if (pts[i] < pts[p0_idx]) p0_idx = i;
    }
    swap(pts[0], pts[p0_idx]);
    Point p0 = pts[0];
    
    // 극각(편각) 기준으로 정렬. 같은 각도라면 거리가 가까운 점이 먼저 오게 정렬.
    sort(pts.begin() + 1, pts.end(), [&](const Point& a, const Point& b)){
        long long cross = ccw(p0, a, b);
        if (cross == 0) return dist2(p0, a) < dist2(p0, b);
        return cross > 0; // a가 b보다 반시계 방향이면 a가 먼저
    };
    
    // 같은 각도(공선)인 점들 중 가장 먼 점만 남기기
    vector<Point> filtered;
    filtered.push_back(p0);
    for (int i = 1; i < n; ++i){
        // scan forward to the last point with same angle
        int j = i;
        while (j + 1 < n && ccw(p0, pts[j], pts[j+1]) == 0) ++j;
        // pts[j] 는 같은 각도 그룹에서 가장 먼 점 (정렬에서 가까운 것이 먼저였으므로)
        filtered.push_back(pts[j]);
        i = j;
    }
    
    // 볼록 껍질 생성
    if ((int)filtered.size() <= 2) {
        // 모든 점이 같은 위치이거나 일직선상에 있을 때: 끝점들만 반환
        // 특이: filtered는 p0 포함, 따라서 그대로 반환 가능
        return filtered;
    }
    
    vector<Point> hull;
    hull.push_back(filtered[0]);
    hull.push_back(filtered[1]);

    for (size_t i = 2; i < filtered.size(); ++i){
        const Point& cur = filtered[i];
        while (hull.size() >= 2 && ccw(hull[hull.size()-2], hull.back(), cur) <= 0){
            hull.pop_back();
        }
        hull.push_back(cur);
    }

    return hull; // CCW 순서로 정렬된 볼록 껍질의 꼭짓점들
}
```

### Monotone Chain
```cpp
# include <bits/stdc++.h>
using namespace std;

struct Point {
		long long x, y;
};

bool operator<(const Point& a, const Point& b){
		if (a.x != b.x) return a.x < b.x;
		return a.y < b.y;
}

// CCW 판정
long long ccw(const Point& A, const Point& B, const Point& C){
		return (B.x - A.x) * (C.y - A.y) - (B.y - A.y)*(C.x-A.x);
}

vector<Point> convexHull(vector<Point>& pts){
    int n = pts.size();
    if (n <= 1) return pts;
    
    sort(pts.begin(), pts.end());
    vector<Point> hull;
    
    // Lower Hull
    for (const auto& p : pts){
            while (hull.size() >= 2 && ccw(hull[hull.size()-2], hull.back(), p) <= 0) {
                    hull.pop_back();
            }
            hull.push_back(p);
    }
    
    // Upper Hull
    int lowerSize = hull.size();
    for (int i = n-2; i>= 0; i--){
            const auto& p = pts[i];
            while((int)hull.size() > lowerSize && ccw(hull[hull.size()-2], hull.back(), p) <= 0){
                    hull.pop_back();
            }
            hull.push_back(p);
    }
    
    hull.pop_back();
    return hull;
}
```

## 활용 팁 및 주의사항
### 일직선 점 처리
- `ccw < 0` vs. `ccw <= 0` 선택에 따라 일직선 상의 점을 포함할 지, 제거할 지 결정됨
- 문제 조건을 반드시 확인

### 정수 오버플로우
- 좌표 범위가 크면 `int` 사용 금지
- `long long` 필수

### 점 개수 예외 처리
- 점이 1개 또는 2개일 경우 그대로 Convex Hull 구성

### 출력 순서
- 대부분의 문제는 반시계 방향, 시작점 자유
- 일부 문제는 시작점/순서를 엄격히 요구함

## 추가 정보
- Convex Hull은 **기하 알고리즘의 출발점**
    - Rotating Calipers
    - 점 집합의 지름
    - 최소 외접 다각형
- 관련 알고리즘
    - Jarvis March (Gift Wrapping) : $O(NH)$
    - QuickHull : 평균은 빠르나, 최악 $O(N^2)$