# Trie

### 개요
- **Trie(트라이)**는 문자열 집합을 효율적으로 저장하고 탐색하기 위한 **트리 기반 자료 구조**
- 문자열의 접두사를 기준으로 노드를 공유하는 것이 핵심
- 일반적인 배열이나 해시 테이블과 달리, 문자열의 길이에 비례한 시간 복잡도로 검색을 수행할 수 있음
    - 문자열 처리 문제가 많은 알고리즘 문제에서 자주 사용됨
- 주요 활용 목적
    - 문자열 존재 여부 확인
    - 접두사 검색
    - 자동 완성
    - 사전 구현

### 기본 아이디어
- 구조적 특징
    - 각 노드는 하나의 문제에 대응됨
    - 루트 노드는 빈 문자열을 의미
    - 문자열 하나는 루트에서 시작해 문자 하나 당 한 단계씩 내려가는 경로로 표현됨
    - 문자열의 끝을 나타내기 위해 표시를 둠
    - 예시
        - `c -> a -> t`
        - `c -> a -> r`
        - `d -> o -> g`
- 시간 복잡도 관점
    - 문자열 삽입
        - $O(L)$
    - 문자열 탐색
        - $O(L)$
    - 문자열의 개수와 무관하게, 길이에만 의존한다는 점이 가장 큰 장점

### 예시 코드
```c++
# include <iostream>
using namespace std;

struct TrieNode {
    TrieNode* = children[26];
    bool isEnd;

    TrieNode(){
        isEnd = false;
        for (int i=0; i<26; i++){
            children[i] = nullptr;
        }
    }
};

class Trie {
private:
    TrieNode* = root;

public:
    Trie() {
        root = new TrieNode();
    }

    // 문자열 삽입
    void insert(const string& word){
        TrieNode* current = root;
        for (char c : word){
            int index = c - 'a';
            if (current -> children[index] == nullptr){
                current -> children[index] = new TrieNode();
            }
            current = current -> children[index];
        }
        current -> isEnd = true;
    }

    // 문자열 검색
    bool search(const string& word){
        TrieNode* current = root;
        for (char c : word){
            int index = c - 'a';
            if (current -> children[index] == nullptr)
                return false;
            current = current -> children[index];
        }
        return current -> isEnd;
    }

    // 접두사 검색
    bool startsWith(const string& prefix){
        TrieNode* current = root;
        for (char c : prefix){
            int index = c - 'a';
            if (current -> children[index] == nullptr)
                return false;
            current = current -> children[index];
        }
        return true;
    }
};
```

### 활용 팁 및 주의 사항
1. 메모리 사용량 주의
    - Trie는 공간 복잡도가 큼
        - 최악의 경우
            - 문자열 개수 $\times$ 문자열의 길이 $\times$ 알파벳 수
        - 특히 `children[26]` 방식은 null 포인터가 많아 메모리 낭비가 심함
    - 개선 방법
        - `map<char, TrieNode*>` 또는 `unordered_map` 사용
        - 입력 문자 종류가 제한적인 경우만 배열 사용
2. 종료 플래그를 반드시 구분할 것
    - `car`와 `cart`를 모두 저장하는 경우
    - `car`의 끝은 `isEnd = true`로 명확히 표시해야 함
    - 이를 놓치면 접두사와 완성 문자열을 구분하지 못하는 오류 발생
3. DFS/BFS와 결합
    - Trie는 트리 구조이므로, 다음과 같은 문제와 결합됨
        - 모든 단어 출력
        - 특정 조건을 만족하는 문자열 탐색
        - 보드 탐색 문제
    - 이 경우, Trie + DFS 조합이 자주 사용됨

### 추가 정보
1. Trie가 자주 등장하는 알고리즘 문제 유형
    - 문자열 집합에서 빠른 검색이 필요한 경우
    - 접두사 기준 분류 문제
    - 자동 완성, 사전, 검색어 추천
    - 문자열 + 그래프 탐색 문제
2. 변형 자료 구조
    - Compressed (Radix Tree)
        - 연속된 단일 경로를 하나의 노드로 압축
    - Ternary Search Trie (TST)
        - 이진 탐색 트리 개념을 접목한 Trie
    - Aho-Corasick
        - 여러 패턴 문자열을 동시에 검색하기 위한 Trie 확장