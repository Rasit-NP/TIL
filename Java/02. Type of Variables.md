# 변수의 타입
### 기본형과 참조형
- 기본형 변수는 **실제 값을 저장**
- 참조형 변수는 어떤 값이 저장되어 있는 **주소를 값으로 저장**
- Java는 C언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수임
- 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용
    - 클래스의 이름이 참조 변수의 타입이 됨
    - 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 것
- 참조 변수의 선언
    ```Java
    Date today = new Date();    // Date 객체를 생성하고, 그 주소를 today에 저장
    ```
    - 객체를 생성하는 연산자 `new`의 결과는 생성된 객체의 주소
    - 이 주소가 대입 연산자에 의해 참조 변수 `today`에 저장

## 기본형(primitive type)
- 기본형에는 모두 8개의 타입이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분됨
- 기본 자료형의 종류와 크기는 반드시 외워야 함
    |  | 1 byte | 2 byte | 4 byte | 8 byte |
    | --- | --- | --- | --- | --- |
    | 논리형 | `boolean` |  |  |  |
    | 문자형 |  | `char` |  |  |
    | 정수형 | `byte` | `short` | `int` | `long` |
    | 실수형 |  |  | `float` | `double` |

## 상수와 리터럴(constant & literal)
```Java
final int MAX_SPEED = 10;
```
- 상수는 변수와 마찬가지로 **값을 저장할 수 있는 공간**
    - 변수와 달리 단 한 번 값을 저장하면 다른 값으로 변경할 수 없음
- 상수를 선언하는 방법은 변수와 동일하며, 단지 변수의 타입 앞에 키워드 `final`을 붙이면 됨

### 리터럴(literal)
- 프로그래밍에서 상수를 **값을 한 번 저장하면 변경할 수 없는 저장공간**으로 정의
- 이와 구분하기 위해 상수를 다른 이름으로 불러야 함
- 따라서 상수 대신 **리터럴**이라는 용어를 사용

### 리터럴의 타입과 접미사
| 종류 | 리터럴 | 접미사 |
| --- | --- | --- |
| 논리형 | false, true | 없음 |
| 정수형 | 123, 0b0101, 077, 0xFF, 100L | `L` |
| 실수형 | 3.14, 3.0e8, 1.4f, 0x1.0p-1 | `f`, `d` |
| 문자형 | ‘A’, ‘1’, ‘\n’ | 없음 |
| 문자열 | “ABC”, “123”, “A”, “true” | 없음 |
- 정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 접미사를 붙여서 타입을 구분
    - 정수형의 경우, `long` 타입의 리터럴에 접미사 `l` 또는 `L`을 붙임
    - 접미사가 없으면 `int` 형의 리터럴
    - 10진수 외에도 2, 8, 16진수로 표현된 리터럴을 변수에 저장할 수 있으며, 16진수라는 것을 표시하기 위해 리터럴 앞에 접두사 `0x` 또는 `0X`를, 8진수의 경우에는 `0`을 붙임
        ```Java
        int octNum = 010;
        int hexNum = 0x10;
        int binNub = 0b10;
        ```
    - JDK 7부터 정수형 리터럴의 중간에 구분자 `_`를 넣을 수 있어 큰 숫자를 편하게 읽을 수 있음
        ```Java
        long bin = 100_000_000_000L;
        long hex = 0xFFFF_FFFF_FFFF_FFFFL;
- 실수형에서는 `float` 타입의 리터럴에 접미사 `f` 또는 `F`를 붙이고, `double` 타입의 리터럴에는 접미사 `d` 또는 `D`를 붙임
    ```java
    float pi = 3.14f;
    double rate = 1.618d;
    ```
    - 실수형에서는 `double`이 기본 자료형이라서 접미사 `d`는 생략 가능

### 타입의 불일치
- 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장봄위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용됨
- 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터럴의 타입의 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생
- `byte`와 `short` 타입의 리터럴은 따로 존재하지 않으므로 `int` 타입의 리터럴을 사용
    ```java
    byte b = 65;
    short s = 0x1234;
    ```
    - 단, 변수가 저장할 수 있는 범위에 속한 것이어야 함

### 지역 변수의 타입 추론 - `var`
```java
var year = 2025;

var map = new LinkedHashMap();
```
- JDK 10부터 지역 변수의 경우, 변수를 선언할 때 타입 대신 `var`를 사용할 수 있음
- 변수의 타입을 생략해도 컴파일러가 값의 타입을 보고 변수의 타입을 추론할 수 있는 것
- 실제 타입 대신 `var`를 사용하면 코드가 간결해지고, 변경에도 유리해짐
- 클래스를 다른 것으로 바꿀 때 변수의 타입은 변경하지 않아도 됨
- 만일 변수를 선언할 때 값을 대입하지 않거나 `null`을 대입하면, 변수의 타입을 추론할 수 없기 때문에 에러가 발생

### 텍스트 블럭
```java
String str2 = """
            Hello""";           // "Hello"와 동일

String str3 = """
            Hello
            """;                // "Hello\n"와 동일

String str4 = """
            Hello
            """;                // "Hello\n"와 동일. 닫는 """의 위치가 들여쓰기의 기준

String str5 = """
            Hello
            """.indent(2);      // str4와 동일. 들여쓰기를 숫자로 지정 가능

String str6 = """
            Hello\
            """;                // "Hello"와 동일. '\'는 한 행의 개행 문자를 제거
```
- JDK 15부터 다중행 문자열 리터럴(multiline string literal)을 작성할 수 있음
- 이 기능은 여러 줄로 이루어진 문자열을 작성하기 편리하게 도와줌