# 다형성
```java
class Tv {
    boolean power;
    int channel;

    void power()        {power = !power;}
    void channelUp()    {++channel;}
    void channelDown()  {--channel;}
}

class CaptionTv extends Tv {
    String text;
    void caption() {...}
}

Tv t = new CaptionTv();
```
- 상속과 함께 객체 지향 개념의 주요한 특징
- 여러 가지 형태를 가질 수 있는 능력을 의미
    - `Java`에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 구현함
    - 조상 타입의 참조 변수로 자손의 인스턴스를 참조할 수 있도록 함
- 자손 타입의 참조 변수로 조상 타입의 인스턴스를 참조하는 것은 허용되지 않음
- 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 함

## 참조 변수의 형변환
- 기본형 변수와 같이 참조 변수도 형변환이 가능
    - 단, 서로 상속 관계에 있는 클래스 사이에서만 가능
    - 조상 타입의 참조 변수를 자손 타입의 참조 변수로의 형변환만 가능
    - 자손 타입의 참조 변수를 조상 타입으로 형변환하는 경우에는 형변환을 생략할 수 있음
- 조상 타입의 참조 변수를 자손 타입의 참조 변수로 변환하는 것을 **다운 캐스팅**
- 자손 타입의 참조 변수를 조상 타입의 참조 변수로 변환하는 것을 **업 캐스팅**이라고 함
- 자손 타입으로의 형변환은 참조 변수가 다룰 수 있는 멤버의 개수를 늘리는 것
    - 실제 인스턴스의 멤버 개수보다 참조 변수가 사용할 수 있는 멤버의 개수가 더 많아지므로 문제가 발생할 수 있음
    - 따라서 자손 타입으로의 형변환은 생략할 수 없음
    - 형변환을 수행하기 전에 `instanceof` 연산자를 사용해 참조 변수가 참조하고 있는 실제 인스턴스의 타입을 확인하는 것이 안전
- 형변환은 참조 변수의 타입을 변환하는 것이지, 인스턴스를 변환하는 것이 아님
    - 참조 변수의 형변환은 인스턴스에 아무런 영향을 미치지 않음
    - 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것 뿐

## `instanceof` 연산자
```java
void doWork(Car c){
    if (c instanceof FireEngine){
        ...
    }
    else if (c instanceof Ambulance){
        ...
    }
}
```
- 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 `instanceof` 연산자를 사용
    - 주로 조건문에 사용되며, `instanceof`의 왼쪽에는 참조 변수를 오른쪽에는 타입이 피연산자로 위치함
    - 연산의 결과로 `boolean` 값인 `true`와 `false` 중의 하나를 반환
- 실제 인스턴스와 같은 타입의 `instanceof` 연산 이외에 조상 타입의 `instanceof` 연산에도 `true`를 반환
    - `instanceof` 연산의 결과가 `true`이면, 검사한 타입으로 형변환을 해도 문제가 없다는 뜻

### `instanceof`를 위한 패턴 매칭
```java
if (c instanceof FireEngine fe){
    fe.water();
}
```
- 많은 경우에 `instanceof`는 참조 변수의 형변환과 같이 사용되기 때문에 `instanceof`의 다음에 오는 형변환을 생략할 수 있는 문법이 추가됨
- 위 코드의 참조 변수 `fe`는 `if` 문의 블럭 내에 선언된 지역 변수
    - 예외적으로 블럭 밖에서도 사용할 수 있음
    - 아래와 같이 간단한 코드를 작성할 수 있게 됨
        ```java
        if (obj instanceof Point p && x==p.x && y==p.y){
            ...
        }
        ```
        - 위와 같이 `instanceof`와 조건식의 결합은 `&&` 연산자를 사용할 때만 가능
        - `||` 연산자는 왼쪽 피연산자가 `false`이어도 오른쪽 피연산자를 평가하기 때문

## 참조 변수와 인스턴스의 연결
- 조상 클래스에 선언된 멤버 변수와 같은 이름의 인스턴스 변수를 자손 클래스에 중복으로 정의했을 때
    - 조상 타입의 참조 변수로 자손 인스턴스를 참조하는 경우와 자손 타입의 참조 변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻음
- 메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩해도 참조 변수의 타입에 관계없이 항상 **인스턴스의 메서드**가 호출됨
- 멤버 변수의 경우 참조 변수의 타입에 따라 달라짐

## 여러 종류의 객체를 배열로 다루기
```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```
- 조상 타입의 참조 변수로 자손 타입의 객체를 참조하는 것이 가능
- 조상 타입의 참조 변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있음