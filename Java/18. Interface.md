# 인터페이스
```java
interface InterfaceName {
    public static final CONST_NAME = value;
    public abstract methodName(parameter);
}
```
- 일종의 추상 클래스
- 추상 메서드를 갖지만, 추상 클래스보다 추상화 정도가 높음
    - 몸통을 갖춘 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없음
    - 추상 메서드와 상수만을 멤버로 가짐
- 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성됨

## 인터페이스의 작성
- 클래스를 작성하는 것과 같음
    - 키워드로 `class`가 아닌 `interface`를 사용
    - 인터페이스에도 클래스와 같이 접근 제어자로 `public` 또는 `default`를 사용할 수 있음
    - 일반적인 클래스의 멤버와 달리 인터페이스의 멤버는 다음과 같은 제약 사항이 있음
        - 모든 멤버 변수는 `public static final`이며 생략할 수 있음
        - 모든 메서드느 `public abstract`이며 생략할 수 있음

## 인터페이스의 상속
```java
interface Movable {}
interface Attackable {}
interface Fightable extends Movable, Attackable {}
```
- 인터페이스는 인터페이스로부터만 상속 받을 수 있음
- 클래스와는 달리 다중 상속이 가능
- 자손 인터페이스는 조상 인터페이스에 정의된 멤버를 모두 상속 받음

## 인터페이스의 구현
```java
class ClassName implements InterfaceName {}
```
- 추상 클래스와 마찬가지로 그 자체로 인스턴스를 생성할 수 없음
- 인터페이스에 정의된 추상 메서드를 구현하는 클래스를 정의함
    - 이 때, 키워드로 `implements`를 사용
- 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, `abstract`를 붙여 추상 클래스로 선언해야 함
    ```java
    abstract class Fighter implements Fightable {}
    ```
- 아래와 같이 상속과 구현을 동시에 할 수도 있음
    ```java
    class Fighter extends Unit implements Fightable {}
    ```

## 인터페이스를 이용한 다중 상속
```java
public class Tv {
    ...
}
public class DVD {
    public void play() {
        ...
    }
}
public interface IDVD {
    public void play();
}

public class TvDVD extends TV implements IDVD {
    DVD dvd = new DVD();

    public void play() {
        dvd.play();
    }
}
```
- 두 개의 클래스로부터 상속을 받아야 하는 상황
    - 두 조상 클래스 중에서 비중이 높은 쪽을 선택해 상속 받고, 다른 한 쪽은 클래스 내부에 멤버로 포함시키는 방식으로 처리
    - 혹은 한 쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현
- 인터페이스를 구현하기 위해 새로 메서드를 작성해야 하는 부담이 있음
- 인스턴스를 사용하면 손쉽게 다중 상속처럼 구현 가능

## 인터페이스를 이용한 다형성
```java
Fightable f = new Fighter();
```
- 클래스와 마찬가지로 인터페이스도 조상 인터페이스 타입의 참조 변수로 구현한 클래스의 인스턴스를 참조할 수 있음
- 따라서 인터페이스는 아래와 같이 메서드의 매개 변수의 타입으로 사용될 수 있음
    ```java
    void attack(Fightable f){
        ...
    }
    ```
    - 인터페이스 타입의 매개 변수가 갖는 의미
        - 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개 변수로 제공해야 한다는 것
- 아래와 같이 메서드의 반환 타입으로 인터페이스 타입을 지정한느 것 역시 가능
    ```java
    Fightable method() {
        ...
        Fighter f = new Fighter();
        return f;
    }
    ```
    - 반환 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미

## 인터페이스의 장점
1. 개발 시간을 단축시킬 수 있음
    - 일단 인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능
        - 메서드를 호출하는 쪽에서는 메서드의 내요에 관계없이 선언부만 알면 되기 때문
    - 인터페이스를 구현하는 클래스를 작성하게 하면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발 진행 가능
2. 표준화가 가능함
    - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성
    - 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함
    - 보다 일관되고 정형화된 프로그램의 개발이 가능
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음
    - 아무런 관계 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있음
4. 독립적인 프로그래밍이 가능
    - 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있음
        - 실제 구현에 독립적인 프로그램을 작성하는 것이 가능
    - 클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용해 간접적인 관계로 변경
        - 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능

## 디폴트 메서드, `static` 메서드, `private` 메서드
- 원래 인터페이스에 추상 메서드만 선언할 수 있었음
- JDK 8부터 디폴트 메서드와 `static` 메서드를, JDK 9부터 `private` 메서드도 추가할 수 있게 되었음
    - 이들은 추상 메서드가 아님

### 디폴트 메서드
```java
interface MyInterface {
    void method();
    default void newMethod() {}
}
```
- 인터페이스에 메서드를 추가한다는 것은 추상 메서드를 추가한다는 것
    - 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야 함
- 디폴트 메서드는 추상 메서드의 기본적인 구현을 제공하는 메서드
    - 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 됨
- 추상 메서드와 달리 일반 메서드처럼 몸통(`{}`)이 있어야 함
- 새로 추가된 디폴트 메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우가 발생함
    1. 여러 인터페이스의 디폴트 메서드 간의 충돌
        - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 해야 함
    2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
        - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시됨

### `private` 메서드
- `private` 메서드는 단지 접근 제어자가 `private`인 일반 메서드
- 디폴트 메서드 또는 `static` 메서드의 중복 코드를 제거하거나 코드를 작업별로 분리하는 과정에서 추가하게 됨
- `private` 메서드를 작성할 때 지켜야 하는 규칙은 아래와 같음
    1. 반드시 구현부가 있어야 함
    2. 접근 제어자는 `private`이며, `static`도 붙일 수 있음
        - `static` 메서드에서 호출하는 `private` 메서드는 `static`을 붙여야 함