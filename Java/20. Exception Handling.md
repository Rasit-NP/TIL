# 예외 처리
## 프로그램 오류
- 프로그램이 오작동을 하거나 비정상적으로 종료되는 원인을 **프로그램 에러** 또는 **오류**라고 함
- 발생 시점에 따라 **컴파일 에러**와 **런타임 에러**로 나눌 수 있음
- 의도한 것과 다르게 동작하는 오류를 **논리적 에러**라고 함
- `Java`에서는 실행 시 발생할 수 있는 오류를 **에러(error)**와 **예외(exception)**로 구분하였음
    - 에러는 메모리 부족(OutOfMemoryError)나 스택 오버플로우(StackOverflowError)와 같이 발생하면 복구할 수 없는 오류
    - 예외는 발생하더라도 수습될 수 있는 미약한 오류
- 예외는 발생하더라도 개발자가 이에 대한 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있음

## 예외 클래스의 계층 구조
- `Java`에서는 실행 시 발생할 수 있는 오류를 클래스로 정의함
    - `Exception`과 `Error` 클래스 역시 `Object` 클래스의 자손임
- 모든 예외의 최고 조상은 `Exception` 클래스이며, 상속 계층도를 그려보면 아래와 같음
    ```
    Exception
    ├── IOException
    ├── ClassNotFoundException
    ├── ...
    └── RuntimeException
        ├── ArithmeticException
        ├── ClassCastException
        ├── NullPointerException
        ├── ...
        └── IndexOutOfBoundsException
    ```
- 예외 클래스들은 두 그룹으로 나눠질 수 있음
    1. `Exception` 클래스와 그 자손들
    2. `RuntimeException` 클래스와 그 자손들
- `RuntimeException` 클래스들은 주로 개발자의 실수에 의해 발생될 수 있는 예외들
- `Exception` 클래스들은 주로 외부의 영향으로 발생
    - 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많음

## 예외 처리하기 - `try-catch` 문
```java
try {
    // 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception1 e1) {
    ...
} catch (Exception2 e2) {
    ...
}
```
- 예외는 개발자가 이에 대한 처리를 미리 해야 함
- 예외 처리(exception handling)란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외에 대비한 코드를 작성하는 것
    - 예외 처리의 목적은 예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지하는 것
- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료
    - 처리되지 못한 예외(uncaught exception)는 JVM의 예외 처리기(UncaughtExceptionHandler)가 받아서 예외의 원인을 화면에 출력
- 예외를 처리하기 위해서는 `try-catch` 문을 사용
    - `try` 블럭에는 실행할 문장을 넣고, `try` 블럭에서 예외가 발생하면 `catch` 블럭 중에서 발생한 예외의 종류와 일치하는 단 하나의 `catch` 블럭만 수행됨
    - 발생한 예외의 종류와 일치하는 `catch` 블럭이 없으면 예외는 처리되지 않음
    - 예외가 발생하면 예외 객체가 생성됨
        - 이 객체에 예외의 정보가 있고 `catch` 블럭에 선언된 참조 변수로 접근할 수 있음

## `try-catch` 문에서의 흐름
- `try` 블럭 내에서 예외가 발생한 경우
    1. 발생한 예외와 일치하는 `catch` 블럭이 있는지 찾음
    2. 일치하는 `catch` 블럭을 찾게 되면, 그 `catch` 블럭 내의 문장들을 수행하고 전체 `try-catch` 문을 빠져나감
        - 만일 일치하는 `catch` 블럭이 없다면, 예외는 처리되지 않음
- `try` 블럭 내에서 예외가 발생하지 않은 경우
    1. `catch` 블럭을 건너뛰고 전체 `try-catch` 문을 빠져나감

## 예외의 발생과 `catch` 블럭
- `catch` 블럭은 괄호(`()`)와 블럭(`{}`)으로 나눠져 있음
    - 괄호(`()`)에는 처리하려는 예외와 같은 타입의 참조 변수를 선언
    - 블럭(`{}`)에는 예외가 발생했을 때 실행될 문장들을 넣음
- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐
    - 첫 번째 `catch` 블럭부터 차례로 내려가면서 `catch` 블럭의 괄호 내에 선언된 참조 변수의 타입과 생성된 예외 인스턴스를 `instanceof` 연산자로 검사
- 모든 예외 클래스는 `Exception`의 자손이므로, `catch` 블럭의 괄호에 `Exception` 타입의 참조 변수를 선언하면 어떤 종류의 예외가 발생해도 이 `catch` 블럭에 의해 처리됨

### `printStackTrace()`와 `getMessage()`
```java
try {
    ...
} catch (Exception e){
    e.printStackTrace();
    System.out.println(e.getMessage());
}
```
- 이 참조 변수는 선언된 `catch` 블럭 내에서만 사용 가능하며, 자주 사용되는 메서드는 아래와 같음
    - `printStackTrace()`
        - 예외 발생 당시의 호출 스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력
    - `getMessage()`
        - 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있음

### 멀티 `catch` 블럭
```java
try {
    ...
} catch (ExceptionA | Exception e) {
    if (e instanceof ExceptionA){
        ExceptionA e1 = (Exception) e;
        e1.method();
    }
    e.printStackTrace();
}
```
- JDK 7부터 여러 `catch` 블럭을 `|` 연산자를 이용해서 하나의 `catch` 블럭으로 합칠 수 있음
- 이를 **멀티 `catch` 블럭**이라고 함
- 멀티 `catch` 블럭을 이용하면 중복된 코드를 줄일 수 있음
- 두 예외 클래스가 조상과 자손의 관계에 있다면, 컴파일 에러가 발생
    - 조상만 써줘야 함
- 하나의 `catch` 블럭으로 여러 예외를 처리했기 때문에 어떤 예외가 발생했는지 알 수 없음
    - 따라서 참조 변수 `e`로 멀티 `catch` 블럭의 예외 클래스들의 공통 조상 예외 클래스에 선언된 멤버만 사용할 수 있음

## 예외 발생시키기
```java
try {
    Exception e = new Exception("고의 발생");
    throw e;
} catch (Exception e){
    System.out.println(e.getMessage());
    e.printStackTrace();
}
```
- 키워드 `throw`를 사용해서 개발자가 고의로 예외를 발생시킬 수 있음
    - 연산자 `new`로 발생시키려는 예외 클래스의 객체를 생성
    - 키워드 `throw`를 이용해서 예외를 발생시킴

## 메서드에 예외 선언하기
```java
void method() throws Exception1, ... ExceptionN {
    ...
}
```
- 예외를 메서드에 선언하는 방법이 있음
    - 실제로 예외를 처리하는 것이 아닌, 예외 처리를 호출한 쪽으로 보내는 것
    - 메서드의 선언부에 예외를 선언함으로써 메서드를 사용하려는 사람이 처리해야 하는 예외들을 쉽게 알 수 있음
- 메서드 내부나 메서드 호출 부분, 어느 한 곳에서는 `try-catch` 문으로 예외 처리를 해주어야 함

## `finally` 블럭
```java
try {
    ...
} catch (Exception e1) {
    ...
} finally {
    ...
}
```
- 예외의 발생 여부에 상관없이 실행되어야 하는 코드를 포함시킬 목적으로 사용됨
- `try-catch` 문의 끝에 선택적으로 덧붙여 사용
    - 예외가 발생한 경우에는 `try-catch-finally`의 순으로 실행
    - 예외가 발생하지 않은 경우에는 `try-finally`의 순으로 실행

## 사용자 정의 예외 만들기
```java
class MyException extends Exception {
    private final int ERR_CODE;

    MyException(String msg, int errCode){
        super(msg);
        ERR_CODE = errCode;
    }

    MyException(String msg){
        this(msg, 100);
    }

    public int getErrCode() {
        return ERR_CODE;
    }
}
```
- 기존 정의된 예외 클래스 외에 개발자가 새로운 예외 클래스를 직접 정의하여 사용할 수 있음
    - 보통 `Exception` 클래스 또는 `RuntimeException` 클래스로부터 상속받아 클래스를 정의
    - 필요에 따라서 알맞은 예외 클래스를 선택해도 됨

## 예외 되던지기(exception re-throwing)
```java
public static void main(String[] args){
    try {
        method();
    } catch (Exception e){
        ...
    }
}

static void method() throws Exception {
    try {
        throw new Exception();
    } catch (Exception e) {
        ...
        throw e;
    }
}
```
- 한 메서드에서 발생할 수 있는 예외가 여럿인 경우
    - 몇 개는 메서드 내에서 자체적으로 처리하고, 나머지는 선언부에 지정하여 호출한 영역에서 처리하도록 할 수 있음
    - 심지어, 단 하나의 예외에 대해서도 예외가 발생한 메서드와 호출한 메서드 양쪽에서 처리할 수도 있음
- 이를 **예외 되던지기(exception re-throwing)**라고 함
- 예외가 발생할 메서드에서 `try-catch` 문을 사용해서 예외를 처리
- `catch` 문에 필요한 작업을 한 후에 `throw` 문을 사용해서 예외를 다시 발생
    - 다시 발생한 예외는 메서드를 호출한 영역에 전달됨

## 연결된 예외(chained exception)
```java
try {
    ...
} catch (Exception e1){
    Exception e2 = new Exception2();
    e2.initCause(e1);
    throw e2;
}
```
- 한 예외가 다른 예외를 발생시킬 수도 있음
- `initCause()`는 `Exception` 클래스의 조상인 `Throwable` 클래스에 정의되어 있어 모든 예외에서 사용 가능
    - `Throwable initCause(Throwable cause)`
        - 지정한 예외를 원인으로 등록
    - `Throwable getCause()`
        - 원인 예외를 반환
- 예외를 발생시키는 이유
    - 여러 가지 예외를 하나의 큰 부류의 예외로 묶어 다루기 위해
    - `checked` 예외를 `unchecked` 예외로 바꿀 수 있도록 하기 위해