# 오버라이딩
```java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;

    String getLocation() {
        return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 상속받은 메서드를 그대로 사용하는 것이 하닌, 자손 클래스에 맞게 변경해야 하는 경우에 조상의 메서드를 오버라이딩함

## 오버라이딩 조건
- 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로, 메서드의 선언부는 조상의 것과 완전히 일치해야 함
- 따라서 선언부가 일치해야 한다는 아래 조건을 만족해야 함
    - 메서드의 이름이 같아야 함
    - 메서드의 매개 변수가 같아야 함
    - 메서드의 반환 타입이 같아야 함
- 다만 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서 다르게 변경할 수 있음
    1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없음
        - 만일 조상 클래스에 정의된 메서드의 접근 제어자가 `protected`라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 `protected`나 `public`이어야 함
        - 대부분의 경우는 같은 범위의 접근 제어자를 사용
    2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음

## `super`
- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수
    - 상속받은 멤버와 자신의 멤버와 이름이 같을 때 `super`를 붙여 구별
- 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 `super`와 `this`는 근본적으로 같음
- `this`와 마찬가지로 `super` 역시 `static` 메서드에서 사용할 수 없고 인스턴스 메서드에서만 사용할 수 있음

## `super()`
- `this()`와 마찬가지로 `super()` 역시 생성자
    - `super()`는 조상 클래스의 생성자를 호출하는데 사용됨
- 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성됨
    - 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있음
    - 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 함
- 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 생성자의 첫 줄에 조상 클래스의 생성자를 호출해야 함
- 조상 클래스 생성자의 호출은 클래스의 상속 관계를 거슬러 올라가면서 반복됨
    - 마지막으로 `Object` 클래스의 생성자인 `Object()`까지 가야 끝이 남
    - 따라서 `Obejct` 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 함
    - 그렇지 않으면 컴파일러는 생성자의 첫 줄에 `super();`를 자동적으로 추가함