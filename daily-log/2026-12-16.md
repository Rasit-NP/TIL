# 2026-01-16

## 🧠 오늘 배운 것
- C++의 연산자 오버로딩, 객체 복사
- 4-Sum 문제와 Meet-in-the-middle

## C++
### 연산자 오버로딩
```cpp
class Student {
public:
    int id;
    int score;

    // '<' 연산자 오버로딩: 점수를 기준으로 비교
    bool operator<(const Student& other) const {
        return this->score < other.score;
    }
};
```
- C++에서는 사용자 정의 타입(클래스)에 대해 `<`, `>`, `+`, `-` 등 기존 연산자의 기능을 새롭게 정의할 수 있음
- 이를 통해 객체 간의 연산을 직관적으로 처리할 수 있음
- 비교 연산자(`<`, `>`)
    - 주로 객체의 특정 멤버 값을 기준으로 대소 관계를 정의할 때 사용
    - 정렬 알고리즘 등에서 활용

### C++의 객체 복사
```cpp
class Item {...};
vector<Item> items = {{1, 1000}, {2, 2000}};

// 1. 값 복사
for (Item obj : items){
    obj.price = 0;  // 복사본의 값을 바꿔도 원본 items 안의 객체는 변하지 않음
}

for (Item& obj : items){
    obj.price = 0;  // 원본 데이터가 수정됨
}
```
- C++에서 객체를 복사할 때, **주소가 아닌 값이 복사**됨
- Java나 Python같은 언어에서 반복문을 사용할 때는 객체의 **참조**가 전달됨
    - C++에서는 별도의 명시가 없으면 **새로운 객체가 생성되며 값이 복사**됨
- C++은 개발자가 메모리 구조와 객체의 수명을 완전히 제어할 수 있게 함
- 객체 복사가 일어날 때는 내부적으로 복사 생성자(Copy Constructor)가 호출하여 원본과 똑같은 값을 지닌 새로운 객체를 스택 메모리에 생성

## 4-Sum Problem
### 문제 개요
- 배열 내의 4개 숫자의 합이 특정 타겟(T)이 되는 조합 찾기
- 4중 `for` 문을 사용할 경우 $O(N^4)$의 시간 복잡도가 발생하여 비효율적

### 핵심 개념
- Meet-in-the-middle
    - 탐색 범위를 절반으로 나누어 각각 계산한 뒤, 그 결과를 조합하여 정답을 찾는 기법
- $a+b+c+d=T$ 식을 $(a-b) = T-(c+d)$로 변환
- 전략
    1. 배열에서 가능한 모든 수의 합($a+b$)을 먼저 구해 해시 맵에 저장
    2. 나머지 두 수의 합($c+d$)을 구하면서, $T-(c+d)$가 해시 맵에 존재하는 지 확인

### 예시 코드
```cpp
# include <iostream>
# include <vector>
using namespace std;

int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);  cout.tie(NULL);

    int w, n;   cin >> w >> n;
    vector<int> nums(n, 0);
    vector<pair<int, int>> sums(400001, {0, 0});
    vector<bool> has_sum(400001, false);
    for (int i=0; i<n; i++){
        cin >> nums[i];
    }
    for (int i=0; i<n; i++){
        for (int j=i+1; j<n; j++){
            int now_sum = nums[i] + nums[j];
            int target = w - now_sum;
            if (target > 0 && target <= 400000 && has_sum[target]){
                if (i != sums[target].first && j != sums[target].first && i != sums[target].second && j != sums[target].second){
                    cout << "YES\n";
                    return 0;
                }
            }
        }
        for (int k=0; k<i; k++){
            if (i != k){
                has_sum[nums[i] + nums[k]] = true;
                sums[nums[i] + nums[k]] = {i, k};
            }
        }
    }
    cout << "NO\n";
    return 0;
}
```
- 반복문 i 내부에 반복문 j와 k로 순회
- i 이후의 값 j 중 $T-(a+b)$가 존재하는지 확인
- 이후에 i 이전의 값 k에 대해 $(c+d) = T-(a+b)$를 저장
- 위 방법으로 임의의 두 원소의 합을 저장하면서, a, b, c, d의 인덱스가 겹치는 것을 막을 수 있음

### 배운 점
- Time-Space Tradeoff
    - $O(N^4)$의 시간을 $O(N^2)$로 줄이는 대신, 모든 수의 합을 저장하기 위한 $O(N^2)$의 공간 복잡도를 사용
    - 주어진 메모리 제한 내에서 최적의 시간 효율을 내는 것이 중요
- 문제 분할
    - 문제를 한 번에 해결하기 보다 **독립적인 두 부분으로 나눠** 해결