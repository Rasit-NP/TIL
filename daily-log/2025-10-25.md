# 2025-10-25

## 🧠 오늘 배운 것
- PyPy의 메모리 초과 문제

### PyPy의 메모리 초과 이유
1. PyPy의 JIT(Just-In-Time) 컴파일 특성
    - PyPy는 실행 중 코드를 분석해 **자주 실행되는 루프나 함수**를 기계어로 컴파일해서 속도를 높임
    - 이 과정에서 **JIT 캐시, 추적 로그, 내부 구조체** 등을 추가로 저장해야 하므로 메모리 사용량이 커짐
    - 특히 재귀 함수는 루프처럼 반복되는 호출이 많으므로, **PyPy가 이를 최적화하려다가 많은 메로리리를 잡아먹음**
2. PyPy의 스택 프레임 구조
    - PyPy는 함수 호출마다 Cpython보다 많은 **메타데이터**를 저장
    - Cpython은 C 스택 위에 얇은 frame 객체를 쌓지만, PyPy는 자체 관리되는 힙 기반 frame을 사용
        - 따라서 재귀 깊이가 깊을 수록 PyPy는 스택 대신 힙 메모리를 많이 소모
3. PyPy의 GC(Garbage Collector) 특성
    - PyPy는 Generational GC를 사용
        - 재귀 중에 계속해서 새로운 frame 객체가 생기고, GC가 이를 정리하지 못하면 일시적으로 메모리 사용량으 폭증
    - CPython은 **참조 카운트 방식**이라 메모리 해제가 즉각적으로 일어나므로 이런 문제가 덜함

### PyPy vs. Python 비교 정리
| 구분 | PyPy | CPython |
|-----|------|---------|
| 실행 속도 | 보통 1.5~5배 빠름 | 느리지만 안정적 |
| 메모리 사용량 | 많음 (2~5배 이상일 때도 있음) | 상대적으로 적음 |
| 함수 호출/재귀 | 느려지고 메모리 부담 큼 | 효율적 |
| 단순 반복문 / 수학 연산 | 매우 빠름 | 느림 |
| 입출력(IO) | 느림 | 보통 |
| JIT 컴파일 | 있음 | 없음 |
| GC 방식 | Generational GC | 참조 카운트 + 순환 GC |
| 초기 구동 속도 | 느림 | 빠름 |
|빌트인 라이브러리 호환성 | 거의 동일 | 완전 호환 |

### PS에서 유리한 경우
| 구분                              | PyPy로 유리                | Python으로 유리 |
| ------------------------------- | ----------------------- | ------------------ |
| 단순 수학 계산, 반복문, 시뮬레이션        | ✅ PyPy (속도 유리)          | ❌ 느림  |
| N^2 이하 복잡도, 많은 연산량        | ✅ PyPy                  | ❌ Python은 시간 초과 위험 |
| 재귀 호출이 깊은 문제 (DFS, 트리 탐색 등) | ❌ PyPy는 메모리 초과 위험       | ✅ Python이 더 안전 |
| 메모리 제한이 빡빡한 문제 (512MB 이하)   | ❌ PyPy는 위험              | ✅ Python |
| 문자열 처리, 파싱, 입출력 중심 문제       | ⚠️ PyPy는 IO가 느려서 오히려 불리 | ✅ Python |
| 메모이제이션 + 재귀 DP              | ❌ PyPy에서 frame 누적 심함    | ✅ Python 안정적 |
| 반복문 DP / 수학적 DP (bottom-up) | ✅ PyPy 빠름               | ❌ Python 느림 |
| 작은 입력 문제                   | 거의 차이 없음                | 거의 차이 없음 |
