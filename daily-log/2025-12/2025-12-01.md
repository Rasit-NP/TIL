# 2025-12-01

## 🧠 오늘 배운 것
- Discord Bot + FastAPI 연동 구조

### 개요
- `main.py`, `bot.py`, `worker.py`, `api.py`의 역할과 상호작용 분석
- 비동기 큐 기반 데이터 전달, worker의 안정적 메시지 전송 로직

### `main.py`
```python
import asyncio
import logging
import uvicorn
from bot import bot
from api import app as fastapi_app
from worker import notice_worker
from config import BOT_API_HOST, BOT_API_PORT, BOT_TOKEN, LOG_LEVEL


logging.basicConfig(level=LOG_LEVEL)
logger = logging.getLogger("main")

async def start_uvicorn():
    """
    uvicorn.Server.serve()는 코루틴이므로 이벤트루프에 task로 등록 가능.
    앱이 단일 프로세스이므로 같은 루프에서 실행.
    """
    config = uvicorn.Config(
        fastapi_app,
        host=BOT_API_HOST,
        port=BOT_API_PORT,
        loop="asyncio",
        log_level="info"
    )
    server = uvicorn.Server(config)
    await server.serve()

def main():
    # 필수 환경 유무 확인
    if not BOT_TOKEN:
        raise RuntimeError("BOT_TOKEN must be set in environment variables (.env or env)")

    loop = asyncio.get_event_loop()

    # 1) FastAPI를 백그라운드 task로 실행
    loop.create_task(start_uvicorn())

    # 2) discord bot 시작 (블로킹 역할이므로 loop.run_until_complete 사용)
    try:
        loop.run_until_complete(bot.start(BOT_TOKEN))
    except KeyboardInterrupt:
        logger.info("Shutdown requested via KeyboardInterrupt")
        loop.run_until_complete(bot.close())
    finally:
        # 안전한 종료를 위해 루프 닫기
        loop.run_until_complete(asyncio.sleep(0.1))
        loop.close()

if __name__ == "__main__":
    main()
```
- **앱 전체의 컨트롤 센터 역할**을 하며, 다른 모듈들은 `main.py`의 호출에 따라 초기화됨
- FastAPI와 Discord Bot이 같은 이벤트 루프를 공유하기 때문에, Task 등록 순서와 블로킹 호출 방식이 매우 중요함
- `main.py`에서 환경 변수 로드, 로그 레벨 설정, 서버 시작 등은 배포할 때 설정만 바꿔서 동일한 코드로 여러 환경에서 실행 가능하게 함
- 역할
    1. 프로그램 진입점
        - Python에서 `__main__`으로 실행되는 파일이며, 서버와 봇을 동시에 시작하도록 함
        - 실행 순서를 관리하여 FastAPI와 Discord Bot, Worker가 올바르게 초기화되도록 함
    2. 환경 변수 로드
        - `.env` 파일을 불러와 BOT_TOKEN, 호스트, 포트, 로깅 레벨 등 필수 설정을 메모리에 로드
        - BOT_TOKEN이 없으면 실행을 중단하도록 체크하여, 보안이나 초기화 문제를 예방
    3. 이벤트 루프 관리
        - `asyncio` 이벤트 루프를 생성하고 FastAPI 서버와 Discord Bot을 동시에 실행할 수 있도록 Task를 등록
        - FastAPI는 `loop.create_task(start_uvicorn())`로 비동기 백그라운드 Task로 실행되고, Discord Bot은 `loop.run_until_complete(bot.start(BOT_TOKEN))`로 블로킹 실행됨
        - 안전한 종료를 위해 KeyBoardInterrupt 처리와 루프 종료까지 포함됨

### `bot.py`
```python
import asyncio
import logging
from discord.ext import commands
import discord
from config import LOG_LEVEL
from worker import notice_worker

# 로거 (모듈 단위 로깅)
logging.basicConfig(level=LOG_LEVEL)
logger = logging.getLogger("bot")

# 필요한 intents 설정
intents = discord.Intents.default()
# 메시지 내용 접근을 원치 않으므로 기본으로 둠
intents.message_content = False

# Bot 인스턴스 (command_prefix는 향후 명령어 확장 시 사용)
bot = commands.Bot(command_prefix="!", intents=intents)

# 전역 비동기 큐: api.py 에서 put(), worker.py 에서 get()
notice_queue: asyncio.Queue = asyncio.Queue()

@bot.event
async def on_ready():
    print(f"Discord bot connected: {bot.user}")
    logger.info("Discord bot connected: %s#%s", bot.user.name, bot.user.discriminator)

    # 봇 연결 완료 시 한 번 실행됨
    bot.loop.create_task(notice_worker(bot, notice_queue))
```
- Discord API와 상호작용하는 **봇 엔진 모듈**
- 큐를 통해 FastAPI에서 들어온 데이터를 Worker에게 안전하게 전달하며, Bot 객체를 Worker에 인자로 전달해 circular import를 회피함
- 새로운 기능을 추가할 때, `bot.py`에 큐만 추가하고 Worker에서 처리하도록 하면 코드 재사용이 쉬워짐
- 역할
    1. Discord Bot 인스턴스 정의
        - `commands.Bot` 객체를 생성하고, 명령어 프리픽스(`!`)와 인텐트(Intents)를 설정
        - 봇이 Discord Gateway에 접속할 때 필요한 권한 범위를 인텐트로 정의
    2. 전역 큐 관리
        - `notice_queue`와 같이 백엔드에서 들어오는 메시지를 Worker가 처리하도록 하는 큐를 정의
        - 큐는 **FastApi -> bot -> worker** 구조에서 데이터 전달을 비동기적으로 담당하며, Discord API 호출 시 동기 문제를 해결
    3. on_ready 이벤트 처리
        - Discord Bot이 Gateway에 연결되어 준비가 완료되면 `on_ready` 이벤트가 발생
        - 여기서 Worker를 실행하도록 Task를 등록, Worker는 큐를 읽어 Discord 채널에 메시지를 전송
        - 봇 로그인과 Worker 실행 순서를 보장하여 `bot.wait_until_ready()` 문제와 circular import 문제를 회피

### `worker.py`
```python
import asyncio
import logging
from typing import Dict
from utils import build_notice_embed
from discord import HTTPException, Forbidden, NotFound
from config import MAX_SEND_RETRIES

logger = logging.getLogger("worker")

async def send_with_retries(channel, embed, max_retries: int = MAX_SEND_RETRIES):
    """
    디스코드 전송 재시도 로직
    - Forbidden/NotFound: 권한이나 채널 문제 -> 재시도하지 않음
    - HTTPException: 일시적 네트워크/서버 문제 -> 재시도
    """
    attempt = 0
    while attempt < max_retries:
        try:
            await channel.send(embed=embed)
            return True
        except Forbidden:
            logger.error("Forbidden to send message to channel %s", getattr(channel, "id", None))
            return False
        except NotFound:
            logger.error("Channel not found: %s", getattr(channel, "id", None))
            return False
        except HTTPException as e:
            attempt += 1
            logger.warning("HTTPException sending message (attempt %d/%d): %s", attempt, max_retries, e)
            await asyncio.sleep(1 * attempt)
    logger.error("Failed to send message after %d attempts", max_retries)
    return False

async def notice_worker(bot, notice_queue: asyncio.Queue):
    """
    무한 루프: 큐에서 항목을 꺼내 채널을 찾고 메시지를 보낸다.
    bot.wait_until_ready()로 봇 준비 완료 후 시작.
    """
    await bot.wait_until_ready()
    logger.info("Notice worker started (bot ready)")

    while True:
        item: Dict = await notice_queue.get()
        try:
            channel_id = int(item["channel_id"])
        except Exception:
            logger.exception("Invalid channel_id in queued item: %s", item)
            notice_queue.task_done()
            continue

        # 캐시 조회
        channel = bot.get_channel(channel_id)
        if channel is None:
            try:
                channel = await bot.fetch_channel(channel_id)
            except Exception as e:
                logger.exception("Failed to fetch channel %s: %s", channel_id, e)
                notice_queue.task_done()
                continue

        embed = build_notice_embed(item)

        success = await send_with_retries(channel, embed)
        if success:
            logger.info("Sent notice to channel %s: %s", channel_id, item.get("title"))
        else:
            logger.warning("Could not send notice to channel %s: %s", channel_id, item.get("title"))

        notice_queue.task_done()
```
- **백엔드와 Discord Bot 사이의 실제 데이터 처리 담당**
- Worker를 여러 개 두어 기능별 큐를 처리하면, 알림 기능을 모듈화하고 확장할 수 있음
- Bot 객체를 인자로 받기 때문에 circular import 문제를 피하면서, `bot.wait_until_ready()`로 안전하게 초기화 후 실행됨
- 역할
    1. 큐 소비자
        - FastAPI가 큐에 넣은 데이터를 가져와 Discord 채널로 전송
        - Worker는 비동기 함수(`async`)로 작성되어 이벤트 루프 내에서 지속적으로 실행됨
    2. Discord 메시지 전송 로직
        - 채널 캐시 조회, fetch 처리, Embed 생성, 재시도 로직까지 포함
        - Forbidden, NotFound, HTTPException 등 다양한 예외를 처리하여 안정적인 메시지 전송을 보장
    3. 데이터 처리 후 큐 작업 완료 알림
        - `queue.task_done()`을 호출하여 큐 내부 상태를 업데이트
        - 이는 큐에서 데이터가 안전하게 처리되었음을 의미하며, 추가 통계나 종료 조건 계산에도 사용될 수 있음

### `api.py` (FastAPI)
```python
from fastapi import FastAPI, Header
from pydantic import BaseModel, Field
from typing import Optional
import logging
from bot import notice_queue  # 전역 큐
from utils import verify_api_key

logger = logging.getLogger("api")
app = FastAPI(title="Discord Bot API")

class NoticeIn(BaseModel):
    channel_id: int
    title: str
    study_id: int
    content: str
    author: str
    url: str | None = None

@app.get("/healthz")
async def healthz():
    return {"status": "ok"}    

@app.get("/notice/")
async def receive_notice(payload: NoticeIn):
    item = payload.dict()
    
    await notice_queue.put(item)
    logger.info(f"Received and queued notice: channel={item['channel_id']} title={item['title']}")

    return {"status": "queued", "channel": item['channel_id']}
```
- **웹 페이지와 Discord Bot 사이의 연결 고리**
- 새로운 기능을 추가할 때, api.py에서 POST 요청을 정의하고 큐에 넣는 것만으로 worker가 처리하도록 쉽게 확장 가능
- 큐를 사용하기 때문에 FastAPI는 요청을 빠르게 반환할 수 있고, 메시지 전송 실패나 지연이 웹 서버 성능에 영향을 주지 않음
- 역할
    1. 웹 서버 API 엔드포인트 제공
        - Discord 알림과 연결되는 POST API를 정의
        - 사용자가 웹 페이지에서 공지사항을 작성하면, 해당 데이터가 이 API로 전달됨
    2. 큐에 데이터 넣기
        - API가 받은 데이터를 bot.py에서 정의한 큐(`notice_queue`)에 넣음
        - Worker가 큐를 소비하면서 실제 Discord 메시지 전송이 이루어짐
    3. 데이터 검증
        - Pydantic 모델을 사용하여 데이터 구조를 검증
        - channel_id, title, content 등의 필수 필드를 확인하고, 잘못된 요청은 HTTPException으로 응답

### 역할 요약
|파일       |역할                                                           |부가 설명                  |
|-------    |------------------------------------------------------------|---------------------------|
|`main.py`|프로그램 진입점, 이벤트 루프 관리, FastAPI와 Bot 실행 순서 제어      |앱 전체 초기화 및 배포 환경 설정|
|`bot.py`|Discord Bot 인스턴스 정의, 큐 관리, `on_ready` 이벤트에서 Worker 실행 |Bot 엔진 역할, 큐를 통해 Worker와 통신|
|`worker.py`|큐 소비자, 메시지 전송, 예외 처리, `task_done` 처리 | 백엔드 -> 큐 -> Discord 메시지 전송 담당 |
|`api.py`| FastAPI 서버, 엔드포인트 정의, 큐에 데이터 넣기 | 웹 페이지와 Discord 알림의 연결고리|

```text
┌───────────────┐
│   웹페이지     │
│  공지사항 작성  │
└───────┬───────┘
        │ POST /notice/ (JSON)
        ▼
┌───────────────┐
│   FastAPI     │
│   api.py      │
│ - 엔드포인트   │
│ - 데이터 검증  │
│ - 큐에 넣기    │
└───────┬───────┘
        │ await notice_queue.put(item)
        ▼
┌───────────────┐
│    bot.py     │
│ - Discord Bot │
│ - notice_queue│
│ - on_ready()  │
│   Worker 실행  │
└───────┬───────┘
        │ notice_queue.get()
        ▼
┌───────────────┐
│  worker.py    │
│ - 큐 소비자    │
│ - 채널 조회    │
│ - Embed 생성   │
│ - 메시지 전송   │
└───────┬───────┘
        │ Discord API
        ▼
┌───────────────┐
│ Discord 채널   │
│  공지 알림     │
└───────────────┘
```