# 2025-10-16

## 🧠 오늘 배운 것
- Django model의 `ForeignKey`와 `ManyToManyField`
- `settings.AUTH_USER_MODEL`과 `get_user_model`의 차이

## `ForeignKey`와 `ManyToManyField`
### `ForeignKey`
    - 한 모델 인스턴스가 다른 모델 인스턴스를 가리키는 외래키
    - 데이터베이스 관점에서는 자식 테이블에 부모의 기본키를 저장하는 컬럼이 생김

### `ManyToManyField`
    - 여러 인스턴스가 서로 다대다 관계를 가질 때 사용
    - Django는 기본적으로 중간 테이블을 생성해서 두 모델의 PK를 연결

### 선언 방법 및 주요 옵션
```python
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)

class Comment(models.Model):
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
    text = models.TextField()

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=200)
    authors = models.ManyToManyField(Author, related_name='books', blank=True)
```
- 주요 옵션
    - `on_delete`(ForeignKey 필수)
        - `CASCADE`, `PROTECT`, `SET_NULL`, `SET_DEAFAULT`, `DO_NOTHING`, `RESTRICT`
    - `related_name`
        - 역참조용 이름(예: `post.comments` 또는 `author.books`)
        - 지정하지 않으면 Django가 자동으로 만듦
    - `blank=True`, `null=True`
        - ManyToMany는 DB 컬럼이 아닌 별도 테이블이므로 `null=True`는 의미가 없음
        - `blank=True`는 폼/관리자에서 빈 값 허용
    - `through`
        - ManyToMany의 중간 모델을 직접 지정해 **추가 필드**를 저장할 수 있음
    - `symmetrical`
        - 자기자신과의 ManyToMany에서 대칭성을 제어
            - 예) 친구 관계 등

### DB 스키마 관점
- ForeignKey
    - 자식 테이블에 `parent_id` 컬럼 생성
    - SQL에서는 JOIN으로 처리
- ManyToMany
    - Django는 자동으로 중간 테이블을 생성
    - 이 테이블은 두 FK 컬럼과 인덱스를 가짐
    - `through` 사용 시 중간 테이블을 직접 정의

### 역참조 사용
- ForeignKey 역참조
    ```python
    post = Post.objects.get(pk=1)
    comments = post.comments.all()      # related_name='comments' 사용 시
    ```
- ManyToMany 역참조
    ```python
    book = Book.objects.get(pk=1)
    authors = book.authors.all()
    author.books.all()      # 역참조
    ```

### ManyToMany 조작 API
- 추가/삭제/설정
    ```python
    book.authors.add(author_instance)
    book.authors.remove(author_instance)
    book.authors.set([a1, a2])  # 기존 관계를 이 리스트로 대체
    book.authors.clear()
    ```
- `through`가 있는 경우는 직접 중간 모델 인스턴스를 만들어 저장하거나
- `through` 모델에서 `objects.create(...)`로 생성해야함
    - 자동 `add()`는 불가하거나 제한됨

### 중간 모델(through)의 사용 예
```python
class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASECADE)
    date_joined = models.DateField()
    role = models.CharField(max_length=50)

class Group(models.Model):
    memebers = models.ManyToManyField(Person, through='Membership')
```

### 제약$\cdot$유의사항
- `on_delete=CASCADE`는 부모 삭제 시 자식도 삭제됨
    - 데이터 손실 주의
    - 보수적으로 `PROTECT`나 `RESTRICT` 고려
- `related_name`를 잘 정의하면 코드 가독성$\uparrow$, 충돌 방지
- ManyToMany의 대량 변경 시 `add()`를 반복 호출하면 비효율적
    - 여러 인스턴스는 `set()`이나 bulk 연산 고려
- `null=True`는 ForeignKey에만 의미 있음
    - ManyToMany에는 사용하지 않음
- DB 수준의 unique/constraint 설정은 필요하면 중간 모델에서 정의

### 마이그레이션 & 관리
- 모델 변경 후 `makemigrations`/`migrate` 수행
    - ManyToMany 필드 추가는 별도의 중간 테이블 마이그레이션 생성
- Django Admin에서 ManyToMany는 기본적으로 선택 위젯(또는 인라인 `through` 모델)으로 관리
    - 대형 테이블은 성능/사용성 고려(수동 검색 위젯, `raw_id_fields` 등)

### 예제 상황별 추천
- 게시글-작성자
    - `ForeignKey(User)`
- 태그-게시글
    - `ManyToMany(Tag)`
- 팀-사용자
    - `ManyToMany through=Membership`
- 프로필-사용자
    - `OneToOneField`

### 트랜잭션과 동시성
- 관계를 변경할 때 여러 쿼리가 발생하면 `transaction.atomic()`으로 묶어 원자성 보장 권장
- 동시성 문제는 DB 제약 및 코드 레벨에서 처리 필요


## `settings.AUTH_USER_MODEL` vs. `get_user_model()`

### 두 방식의 차이
| 구분       | `settings.AUTH_USER_MODEL`                     | `get_user_model()`|
| -------- | ---------------------------------------------- | ------------------------------------------ |
| 형태       | 문자열 (`'accounts.User'`)                        | 실제 User 클래스 객체|
| 사용 시점    | **모델 정의할 때 (import 시점)**                       | **실행 시점 (runtime)**|
| 주로 사용 위치 | `models.py`, `ForeignKey`, `ManyToManyField` 등 | `views.py`, `serializers.py`, `forms.py` 등|
| 예시       | `ForeignKey(settings.AUTH_USER_MODEL, ...)`    | `User = get_user_model()` 후 사용|

### 모델에서는 `settings.AUTH_USER_MODEL`을 써야 하는 이유
- `models.py`는 Django가 앱을 로드할 때 가장 먼저 import함
    - 이 시점에서는 User 모델이 아직 완전히 로드되지 않았을 수 있음
- `get_user_model()`은 내부적으로 `django.contrib.auth.get_user_model()`을 통해 **이미 등록된 User 모델 클래스를 반환**하는데
    - 이 호출이 너무 일찍 일어나면 아직 `User` 클래스가 등록되지 않은 상태일 수 있음

### 권장되는 올바른 방법
- Django 공식 문서에서도 아래를 권장
> Use `settings.AUTH_USER_MODEL` for model fields.$\\$
Use `get_user_model()` for runtime access to the user model.

### `get_user_model()`의 사용
- **실제 코드 실행 중에 User 모델이 필요할 때** 사용
    - views, serializers, commands, forms 등에서 사용 가능