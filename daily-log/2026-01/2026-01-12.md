# 2026-01-12

## 🧠 오늘 배운 것
- C++에서의 `map`/`set`과 `unordered_map`/`unordered_set`의 차이
---
### 주요 차이점 요약 테이블
|구분   |`map`/`set`    |`unordered_map`/`unordered_set`    |
|------|----------------|----------------------------------|
|내부 자료 구조 |**Red-Black Tree**(균형 이진 탐색 트리)    |**Hash Table**(해시 테이블)        |
|데이터 순서    |키(Key) 기준 **오름차순 정렬**             |**순서 없음** (삽입 순서와 무관)   |
|탐색/삽입/삭제 |$O(\log{n})$                           |평균 $O(1)$, 최악 $O(n)$           |
|메모리 사용량  |상대적으로 적음                            |해시 버킷 때문에 상대적으로 많음   |
|필요 조건      |`operator <`(비교 연산자) 정의             |해시 함수, `operator ==` 정의   |
---
### 상세 비교
1. 내부 구조와 정렬
    - `map` & `set`
        - 자가 균형 이진 탐색 트리인 **Red-Black Tree**를 기반으로 구현됨
        - 데이터를 넣는 순간 자동으로 정렬된 상태를 유지함
    - `unordered_map` & `unordered_set`
        - **해시 테이블**을 기반으로 구현됨
        - 데이터가 해시 함수에 의해 임의의 버킷에 담기기 때문에 순서가 보장되지 않음
        - 평균적인 성능은 훨씬 빠름
2. 시간 복잡도
    - `map` & `set`
        - 데이터가 $n$개일 때 탐색에 항상 $O(\log{n})$의 시간이 걸림
        - 데이터 양이 많아져도 성능 저하가 비교적 예측 가능함
    - `unordered_map` & `unordered_set`
        - 해시 충돌이 거의 없다는 가정하에 $O(1)$이라는 매우 빠른 속도
        - 해시 충돌이 빈번하게 발생하는 최악의 상황에는 $O(n)$까지 느려질 수 있음
3. 요구 사항
    - `map` & `set`
        - 키 값들을 서로 비교할 수 있어야 하므로 `<` 연산자가 정의되어 있어야 함
            - 사용자 정의 객체를 키로 쓸 경우 중요
    - `unordered_map` & `unordered_set`
        - 키의 해시값을 계산할 수 있는 함수와, 두 키가 같은지 비교할 수 있는 `==` 연산자가 필요
        - 기본 타입(`int`, `string` 등)은 표준 라이브러리에서 기본적으로 제공
---
### 추천 상황
- `map` & `set`
    - 데이터를 항상 정렬된 상태로 유지해야 할 때
    - 범위 탐색이 필요할 때
    - 데이터의 양이 아주 많지 않고, 일관된 성능($O(\log{n}))이 중요할 때
- `unordered_map` & `unordered_set`
    - 데이터의 순서가 전혀 중요하지 않을 때
    - 최대한 빠른 성능($O(1)$)으로 데이터를 찾거나 삽입해야 할 때
    - 데이터가 매우 많아 $O(\log{n})$조차 부담스러울 때