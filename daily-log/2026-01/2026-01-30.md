# 2026-01-30

## 🧠 오늘 배운 것
- HTTPS 통합 배포(main, dev 환경 분리)

## 인프라 사전 준비
### AWS 보안 그룹(Security Group) 설정
- 아래 포트가 열려 있는지 확인
- **Prod용** : TCP 443(HTTPS)
- **Dev용** : TCP **(HTTPS Alternate)
    - Dev 서버에서도 HTTPS를 사용할 때, 도메인은 하나인데 서브도메인을 사용할 수 없는 경우, 포트로 구분해야 함
### SSL 인증서 발급
```bash
# 80 포트를 사용하는 컨테이너가 있다면 잠시 중지 후 실행
sudo certbot certonly --standalone -d my_domain
```
- 인증서는 호스트(EC2)에 한 번만 발급받고, 이를 Prod와 Dev 컨테이너가 **읽기 전용**으로 공유해서 사용
- **확인** : `/etc/letsencrypt/live/my_domain/` 경로에 `fullchain.pem`, `privkey.pem` 생성 완료

## 공통 코드 작성
- Prod와 Dev가 동일한 파일을 사용하는 부분

### Nginx 설정 파일(`/nginx/nginx.conf`)
```nginx
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 1. HTTP(80) -> HTTPS 리다이렉트
    server {
        listen 80;
        server_name i14a708.p.ssafy.io;
        return 301 https://$host$request_uri;
    }

    # 2. HTTPS 서버 (내부는 무조건 443)
    server {
        listen 443 ssl;
        server_name i14a708.p.ssafy.io;

        # 인증서 경로 (Docker Volume으로 마운트 될 예정)
        ssl_certificate /etc/letsencrypt/live/i14a708.p.ssafy.io/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/i14a708.p.ssafy.io/privkey.pem;

        # 프론트엔드 연결
        location / {
            # docker-compose에서 서비스 이름을 'frontend'로 통일할 것입니다.
            proxy_pass http://frontend:80;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 백엔드 연결
        location /api/ {
            # 백엔드 api 요청에서 `api`를 제거(필요에 따라 생략 가능)
            rewrite ^/api(/.*)$ $1 break;
            # docker-compose에서 서비스 이름을 'backend'로 통일할 것입니다.
            proxy_pass http://backend:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```
- 프로젝트 루트 혹은 적절한 위치에 `nginx` 폴더를 만들고 그 안에 `nginx.conf`를 작성
- **중요** : 여기서는 포트를 `443`으로만 설정
    - Dev가 외부에서 다른 포트를 사용해도, Nginx 내부에서는 443으로 동작함

## 환경별 구성(Docker Compose & .env)
- 배포 시점에 달라지는 부분

### 운영(Prod) 환경 설정
- `.env`
    ```properties
    # 기본 HTTPS 포트 사용
    REACT_APP_API_URL=https://my_domain
    ...
    ```
- `docker-compose.prod.yml`
    ```yaml
    services:
        nginx:
            image: nginx:latest
            container_name: nginx-prod
            ports:
                - "80:80"
                - "443:443"  # [핵심] 정직한 매핑
            volumes:
                - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro  # 설정 파일
                - /etc/letsencrypt:/etc/letsencrypt:ro         # 호스트 인증서
            depends_on:
                - frontend
                - backend
            restart: always
        frontend:
            build:
                context: ./FE
                dockerfile: Dockerfile
            container_name: frontend-prod # 컨테이너 이름은 달라야 함
            expose:
                - "80" # 외부 노출 X, 내부 Nginx랑만 통신
            restart: always

        backend:
            build:
                context: ./BE
                dockerfile: Dockerfile
            container_name: backend-prod
            expose:
            - "8080" # 외부 노출 X
            depends_on:
            - db
            restart: always
        db:
            ...
    ```
    - **포트** : 호스트 `443` -> 컨테이너 `443`

### 개발(Dev) 환경 설정
- `.env`
    ```properties
    # 개발은 8443 포트 사용
    REACT_APP_API_URL=https://my_domain:8443
    ...
    ```
- `docker-compose.develop.yml`
    ```yaml
    services:
        nginx:
            image: nginx:latest
            container_name: nginx-dev
            ports:
                # [핵심 매핑]
                # 외부에서 8443으로 들어오면 -> 내부의 443(nginx.conf설정)으로 토스
                - "8443:443"
            volumes:
                - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro  # Prod와 완전히 똑같은 파일 사용!
                - /etc/letsencrypt:/etc/letsencrypt:ro         # 인증서 공유
            depends_on:
                - frontend
                - backend
            restart: always
        frontend:
            build:
                context: ./FE
                dockerfile: Dockerfile
            container_name: frontend-dev # 컨테이너 이름 충돌 방지
            expose:
                - "80"
            restart: always

        backend:
            build:
                context: ./BE
                dockerfile: Dockerfile
            container_name: backend-dev # 컨테이너 이름 충돌 방지
            expose:
                - "8080"
            depends_on:
                - db
            restart: always
        
        db:
            ...
    ```
    - **포트** : 호스트 `8443` -> 컨테이너 `443`
    - **서비스 이름** : Prod와 **동일**하게 유지하여 `nginx.conf` 재사용

## 배포 및 실행
### 개발 서버 실행
```bash
cd ~/project_dev
sudo docker compose -f docker-compose.develop.yml up -d --build
```

### 운영 서버 실행
```bash
cd ~/project_prod
sudo docker compose -f docker-compose.prod.yml up -d --build
```

## 최종 결과 확인
- 동일한 도메인에서 포트만 바꿔서 접속 시도

### 일반 유저(Prod)
- `https://my_domain`
- 요청 흐름
    - 유저 -> 호스트 `443` -> Prod Nginx `443` -> Prod 컨테이너

### 개발자(Dev)
- `https://my_domain:8443`
- 요청 흐름
    - 개발자 -> **호스트 `8443`** -> **Dev Nginx `443`** -> Dev 컨테이너