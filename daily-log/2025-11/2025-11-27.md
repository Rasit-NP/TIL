# 2025-11-27

## 🧠 오늘 배운 것
- Django ORM `update_or_create`

### 개요
- `update_or_create` 메서드는 모델 객체를 검색하고 있으면 생성, 있으면 업데이트하는 ORM 유틸리티
- **존재하면 업데이트, 존재하지 않으면 새로 생성**이라는 원자적 연산을 수행

### 시그니처
```python
Model.objects.update_or_create(defaults=None, **lookup)
```
- `lookup`: 객체를 검색할 때 사용할 조건
    - `id=1`, `username='alice'`
- `defaults`
    - 검색 결과가 존재하면 업데이트, 없으면 생성 시 적용할 필드 딕셔너리
    - 변환 값
        - `(object, created)` 튜플
- `object`
    - 생성 또는 업데이트된 모델 인스턴스
- `created`
    - `True`
        - 새로 생성
    - `False`
        - 기존 객체 업데이트

### 동작 과정
1. 검색 조건 적용
    ```python
    obj = Model.objects.filter(**lookup).first()
    ```
2. 객체 존재 여부 판단
    - 존재하면 `defaults`에 있는 값으로 업데이트
    - 존재하지 않으면 `lookup` + `defaults`를 합쳐 새 객체 생성
3. 저장
    - DB에 저장 후 반환
- **원자성 보장**
    - 내부적으로 `transaction.atomic()`이 적용되어 잇어, race condition 방지 가능

### 예시 1: 기본 사용
```python
user, created = User.objects.update_or_create(
    username='alice',
    defaults={'email': 'alice@example.com', 'is_active': True}
)
```
- `username='alice'` 조건으로 검색
- 존재하면 이메일과 `is_active` 업데이트
- 존재하지 않으면 새 User 객체 생성

### 예시 2: ForeignKey 포함
```python
user = User.objects.get(username='alice')
profile, created = Profile.objects.update_or_create(
    user=user,
    defaults = {'nickname': 'AliceInWonderLand'}
)
```
- `guild_id` 기준 검색
- 존재하면 이름과 `is_active` 업데이트
- 존재하지 않으면 새 Model 객체 생성

### 주의사항
1. 반환 값은 항상 `(object, created)` 튜플
2. 검색 조건과 업데이트 값 구분
    - `lookup` -> 검색할 필드
    - `defaults` -> 새로 생성하거나 업데이트할 값
    - `lookup`에 없는 값을 `defaults`에 넣으면, 기존 객체 존재 시 값만 업데이트 됨
3. unique_together나 OneToOneField와 함께 쓸 때
    - 검색 조건(`lookup`)이 유일키/primary key를 포함해야 안전
    - 그렇지 않으면 `MultipleObjectsReturned` 오류 가능
4. ForeignKey 필드
    - `defaults`에 ForeignKey 객체를 넣어야 함
    - 숫자(id)만 넣으면 오류 발생
5. Atomic 처리
    - 내부적으로 transaction.atomic() 적용
    - race condition과 동시성 문제 최소화