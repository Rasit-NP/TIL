# Flow of Control
# 조건문
### `if`
```javascript
const name = 'customer'
if (name === 'admin') {
		console.log('관리자님 환영해요')
} else if (name === 'customer') {
		console.log('고객님 환영해요')
} else {
		console.log('반갑습니다. ${name}님')
}
```
- 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단

### 삼항 연산자
```javascript
const age = 20
const message = (age >= 18) ? '성인' : '미성년자'
console.log(message) // '성인'
```
- 간단한 조건부 로직을 간결하게 표현할 때 유용
- 복잡한 로직이나 대다수의 경우에는 가독성이 떨어질 수 있으므로 적절한 상황에서만 사용할 것
- condition
    - 평가할 조건(`true` 또는 `false`로 평가)
- expression1
    - 조건이 `true`일 경우 반환할 값 또는 표현식
- expression2
    - 조건이 `false`일 경우 반환할 값 또는 표현식

# 반복문
### 반복문 종류
- `while`
- `for`
- `for ... in`
- `for ... of`

### while 반복문
```javascript
while (조건문) {
	// do something
}

let i = 0
while (i < 6) {
		console.log(i)
		i += 1
}
```
- 조건문이 참이면 문장을 계속해서 수행

### for 반복문
```javascript
for ([초기문]; [조건문]; [증감문]){
		// do something
}

for (let i=0; i < 6 ; i++) {
		console.log(i)
}
```
- 특정한 조건이 거짓으로 판별될 때까지 반복

## for $\cdots$ in
### `for ... in` 반복문
```javascript
for (variable in object) {
		statement
}

const fruits = {a: 'apple', b: 'banna'}
for (const property in object) {
		console.log(property)          // a, b
		console.log(object[property])  // apple, banana
}
```
- 객체의 열거 가능한(enumerable) 속성의 키에 대해 반복

## for $\cdots$ of
### `for ... of` 반복문
```javascript
for (variable of iterable) {
		statement
}

const numbers = [0, 1, 2, 3]
for (const number of numbers) {
		console.log(number)
}
```
- 반복 가능한(iterable) 객체(배열, 문자열 등)의 값에 대해 반복

## for $\cdots$ in과 for $\cdots$ of
### 배열 반복과 `for ... in`
- 객체의 관점에서 보면, 배열의 인덱스도 "정수 형태의 이름을 가진 열거 가능한 속성"
- `for ... in`은 정수가 아닌 이름과 속성을 포함하여 열거 가능한 모든 속성을 반환
- 내부적으로 `for ... in`은 배열의 반복자가 아닌 속성 열거를 사용하기 때문에 특정 순서에 따라 인덱스를 반환하는 것을 보장할 수 없음
- 따라서 `for ... in`은 인덱스의 순서가 중요한 배열에서는 사용하지 않음
- 배열에서는 `for` 문, `for ... of`를 사용

### 반복문 사용 시 `const` 사용 여부
- for 문
    - `for (let i=0; i<arr.length; i++) { ... }`의 경우에는 최초 정의한 `i`를 "재할당"하면서 사용하기 때문에 `const`를 사용하면 에러 발생
- `for ... in`, `for ... of`
    - 재할당이 아니라, 매 반복마다 다른 속성 이름이 변수에 저장되는 것이므로 `const`를 사용해도 에러가 발생하지 않음
    - 단, `const` 특징에 따라 블록 내부에서 변수를 수정할 수 없음