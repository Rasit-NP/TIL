# 객체

### Object

- 키로 구분된 데이터 집합을 저장하는 자료형

## 구조 및 속성

### 객체 구조

```jsx
const user = {
		name: 'Alice',
		'key with space': true,
		greeting: funmction(){
				return 'hello'
		}
}
```

- 중괄호(`{}`)를 이용해 작성
- 중괄호 안에는 key:value 쌍으로 구성된 속성(property)를 여러 개 작성 가능
- key는 문자형만 허용
- value는 모든 자료형 허용

### 속성 참조

```jsx
console.log(user.name)
console.log(user['key with space'])

// 추가
user.address = 'korea'

// 수정
user.name = 'Bella'

// 삭제
delete user.name
```

- 점(`.`) 표기법 또는 대괄호(`[]`) 표기법으로 객체 속성에 접근
- key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능

### `in` 연산자

```jsx
console.log('greeting' in user) // true
console.log('country' in user)  // false
```

- 속성이 객체에 존재하는지 여부를 확인
- 객체의 키나 배열의 인덱스 존재 여부를 확인하는 연산자
- 객체에서 값의 포함 여부를 확인하려면, `in` 연산자 대신 `hasOwnProperty()` 메서드를 사용하는 것이 올바름
- 프로토타입 체인을 따라 상속된 속성까지 확인하므로, 의도치 않게 `true`가 나올 수 있어 주의해야 함

## 메서드

### Method

```jsx
console.log(user.greeting())
```

- 객체 속성에 정의된 함수
- `object.method()` 방식으로 호출
- 메서드는 객체가 ‘행동’할 수 있게 함

### Method 기본 문법

```jsx
const myObj2 = {
		numbers: [1, 2, 3],
		myFunc: function() {
				this.numbers.forEach(function (number) {
						console.log(this)
				})
		}
}

console.log(myObj2.myFunc())
```

- 메서드도 값이 함수인 속성
- 메서드와 일반 함수의 차이
    - 메서드는 자신이 속한 객체의 다른 속성들에 접근할 수 있음
    - 이를 위한 방법이 `this`

## this

### `this` keyword

- 함수나 메서드를 호출한 객체를 가리키는 키워드
- `this` 키워드를 사용해 객체에 대한 특정한 작업을 수행할 수 있음

### Method & this 사용 예시

```jsx
const person = {
		name: 'Alice',
		greeting: function() {
				return `Hello my name is ${this.name}`
		},
}

console.log(person.greeting())
```

### 함수의 호출 방법

| 호출 방법 | 대상 |
| --- | --- |
| 일반 함수에서의 단순 호출 | 전역 객체 |
| 객체에서의 메서드 호출 | 메서드를 호출한 객체 |

### 중첩된 함수에서의 this 문제점

```jsx
const myObj2 = {
		numbers: [1, 2, 3],
		myFunc: function() {
				this.numbers.forEach(function (number) {
						console.log(this)
				})
		}
}

console.log(myObj2.myFunc())
```

- `forEach`의 인자로 전달된 콜백 함수는 일반 함수로 호출되므로, this는 전역 객체를 가리킴
- 해결책
    
    ```jsx
    const myObj3 = {
    		numbers: [1, 2, 3],
    		myFunc: function() {
    				this.numbers.forEach((number) =>
    				{console.log(this)})
    		}
    }
    
    console.log(myObj3.myFunc())
    ```
    
    - 화살표 함수는 자신만의 this를 가지지 않음
    - 따라서 외부 함수에서 this의 값을 가져옴

### JavaScript `this` 정리

- JavaScript의 함수는 호출될 때 this를 암묵적으로 전달 받음
- JavaScript에서 this는 함수가 호출되는 방식에 따라 결정되는 현재 객체를 나타냄
- Python의 self와 Java의 this가 선언 시점에 이미 정해지는 것과 달리 JavaScript의 this는 함수가 호출될 때 동적으로 결정
- 장점
    - 함수(메서드)를 하나만 만들어 여러 객체가 공유하여 각자 자신의 데이터로 동작하게 할 수 있음
- 단점
    - 이런 유연함이 실수러 이어질 수 있음

## 추가 객체 문법

### 추가 객체 문법

1. 단축 속성
    
    ```jsx
    const name = 'Alice'
    const age = 30
    const user = {
    		name,
    		age,
    }
    ```
    
    - 키 이름과 값으로 쓰이는 변수의 이름이 같은 경우 단축 구문을 사용할 수 있음
2. 단축 메서드
    
    ```jsx
    const myObj1 = {
    		myFunc() {
    				return 'Hello'
    		}
    }
    ```
    
    - 메서드 선언 시 function 키워드 생략 가능
3. 계산된 속성(computed property name)
    
    ```jsx
    const product = prompt('물건 이름을 입력해주세요')
    const prefix = 'my'
    const suffix = 'property'
    const bag = {
    		[product]: 5,
    		[prefix + suffix]: 'value',
    }
    console.log(bag) // {연필: 5, myproperty: 'value'}
    ```
    
    - 키가 대괄호(`[]`)로 둘러싸여 있는 속성
        - 고정된 값이 아닌 변수 값을 사용할 수 있음
    - 대괄호 안의 표현식이 너무 복잡해지면, 어떤 키가 생성될 지 파악하기 어려워 가독성이 떨어질 수 있음
    - 동적으로 키를 만들다 보면 의도치 않게 같은 이름의 키가 생성되어, 기존 값이 덮어써질 위험이 있음
4. 구조 분해 할당(destructing assignment)
    
    ```jsx
    const userInfo = {
    		firstName: 'Alice',
    		userId: 'alice123',
    		email: 'alice123@gmail.com'
    }
    const { firstName } = userInfo
    const { firstName, userId } = userInfo
    const { firstName, userId, email } = userInfo
    
    console.log(firstName, userId, email)
    ```
    
    ```jsx
    const person = {
    		name: 'Bob',
    		age: 35,
    		city: 'London',
    }
    
    function printInfo({ name, age, city }) {
    		console.log(`이름: ${name}, 나이: ${age}, 도시: ${city}`)
    }
    
    // 함수 호출 시 객체를 구조 분해하여 함수의 매개변수로 전달
    printInfo(person)
    ```
    
    - 배열 또는 객체를 분해하여 객체 속성을 변수에 쉽게 할당할 수 있음
    - 함수의 매개변수로 구조 분해 할당 활용 가능
5. 객체와 전개 구문(Spread Syntax)
    
    ```jsx
    const obj = {b: 2, c: 3, d: 4}
    const newObj = {a: 1, ...obj, e: 5}
    console.log(newObj)  // {a: 1, b: 2, c: 3, d: 4, e: 5}
    ```
    
    - 객체 복사
        - 객체 내부에서 객체 전개
    - 얕은 복사에 활용 가능
6. 유용한 객체 메서드
    - `Object.keys()`
        - Object의 Key 값들을 리스트로 반환
    - `Object.values()`
        - Object의 Value 값들을 리스트로 반환
    - `Object.entries()`
        - Object의 key와 value 값들을 한 쌍으로 묶은 리스트로 반환
7. Optional chaining(`?.`)
    
    ```jsx
    const user = {
    		name: 'Alice',
    		greeting: function() {
    				return 'hello'
    		}
    }
    
    console.log(user.address.street)    // Uncaught TypeError
    console.log(user.address?.street)   // undefined
    
    console.log(user.nonMethod())       // Uncaught TypeError
    console.log(user.nonMethod?.())     // undefined
    ```
    
    - 속성이 없는 중첩 객체에 접근하려 할 때 에러 발생 없이 안전하게 접근하는 방법
    - 만약 참조 대상이 null 또는 undefined라면 에러가 발생하는 것 대신 평가를 멈추고 undefined를 반환
    - 장점
        - 참조가 누락될 가능성이 있는 경우 연결된 속성으로 접근할 때 더 짧고 간단한 표현식을 작성할 수 있음
        - 어떤 속성이 필요한 지에 대한 보증이 확실하지 않는 경우에 객체의 내용을 보다 편리하게 탐색할 수 있음
        - 만약 Optional chaining을 사용하지 않는다면 다음과 같이 `&&` 연산자를 사용해야 함
            
            ```jsx
            console.log(user.address && user.address.street) // undefined
            ```
            
    - 주의 사항
        - Optional chaining은 존재하지 않아도 괜찮은 대상에만 사용해야 함
            - 왼쪽 평가대상이 없어도 괜찮은 경우에만 선택적으로 사용
            - 중첩 객체를 에러 없이 접근하는 것이 사용 목적이기 때문
        - Optional chaining 앞의 변수는 반드시 선언되어 있어야 함

## JSON

### JSON

- JavaScript Object Notation
- Key-Value 형태로 이루어진 자료 표기법
- JavaScript의 Object와 유사한 구조를 가지고 있지만, JSON은 일정한 형식을 가진 **문자열**
- JavaScript에서 JSON을 사용하기 위해서는 Object 자료형으로 변경해야 함
- 특정 언어에 종속되지 않는 데이터 형식으로, API 통신 등에서 널리 사용됨

### Object → JSON

```jsx
const objToJson = JSON.stringify(jsObject)
```

- `JSON.stringfy()`를 사용해 객체를 문자열로 변환

### JSON → Object

```jsx
const jsonToObj = JSON.parse(objToJson)
```

- `JSON.parse()`를 사용해 문자열을 객체로 변환